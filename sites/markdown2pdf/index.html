<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown to PDF - 1135</title>
    <link rel="icon" type="image/x-icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../css/style.css">
    <script src="../../js/vendor/marked.min.js"></script>
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script>
        // Load highlight.js - use cdnjs as primary (more reliable)
        function loadHighlightJS() {
            const script = document.createElement('script');
            // Use cdnjs as primary CDN (more reliable)
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js';
            script.onerror = function () {
                console.warn('Failed to load highlight.js from cdnjs, trying jsdelivr as fallback...');
                const fallbackScript = document.createElement('script');
                fallbackScript.src = 'https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/highlight.min.js';
                fallbackScript.onerror = function () {
                    console.error('Failed to load highlight.js from all CDNs. Code highlighting will not work.');
                };
                document.head.appendChild(fallbackScript);
            };
            document.head.appendChild(script);
        }
        loadHighlightJS();
    </script>
    <script src="../../js/vendor/mermaid.min.js"></script>
    <!-- Use jsdelivr for html-docx-js to avoid CORB issues -->
    <script src="../../js/vendor/html-docx.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/watermark-dom@2.3.0/index.min.js"></script> <!-- Watermark Library -->
    <!-- PDF Generation Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

    <script src="../../js/main.js"
        onerror="console.error('Failed to load main.js. Please check the file path and network connection.');"></script>
    <script>
        // Verify main.js loaded successfully immediately after loading
        (function () {
            // Check if md2pdfSyncScroll is available right after main.js loads
            const checkSyncScroll = () => {
                const available = typeof md2pdfSyncScroll !== 'undefined' ||
                    (typeof window !== 'undefined' && window.md2pdfSyncScroll);

                if (!available) {
                    console.error('md2pdfSyncScroll is not available after main.js load.');
                    console.log('Diagnostics:', {
                        'md2pdfSyncScroll direct': typeof md2pdfSyncScroll !== 'undefined',
                        'window.md2pdfSyncScroll': typeof window !== 'undefined' && typeof window.md2pdfSyncScroll !== 'undefined',
                        'translations available': typeof translations !== 'undefined',
                        'applyLanguage available': typeof applyLanguage === 'function'
                    });
                } else {
                    console.log('✓ md2pdfSyncScroll loaded successfully');
                }
                return available;
            };

            // Check immediately
            if (!checkSyncScroll()) {
                // Retry after a short delay in case of async loading
                setTimeout(() => {
                    if (!checkSyncScroll()) {
                        console.error('md2pdfSyncScroll still not available after delay. Please check main.js for errors.');
                    }
                }, 50);
            }
        })();

        // Configure MathJax BEFORE loading the script
        // MathJax 3.x configuration
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true,
                autoload: {
                    color: [],
                    colorv2: ['color']
                },
                packages: { '[+]': ['ams', 'newcommand', 'configMacros'] }
            },
            svg: {
                fontCache: 'global'
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            startup: {
                ready: () => {
                    console.log('MathJax is loaded, but not yet initialized');
                    MathJax.startup.defaultReady();
                    console.log('MathJax is initialized, and the initial typeset is queued');

                    // Trigger updatePreview after MathJax is ready to render any LaTeX in the default content
                    // rely on MathJax.startup.promise which resolves when initial typesetting is done
                    MathJax.startup.promise.then(() => {
                        if (document.getElementById('enable-latex')?.checked) {
                            // Only trigger updatePreview if the page is fully loaded.
                            // If the page is still loading, the DOMContentLoaded listener will handle the initial render
                            // (which includes setting the input value and calling updatePreview).
                            // This prevents rendering empty content or race conditions.
                            if (document.readyState === 'complete' || document.readyState === 'interactive') {
                                setTimeout(() => {
                                    if (typeof updatePreview === 'function') {
                                        console.log('MathJax ready & Page loaded - updating preview');
                                        updatePreview();
                                    }
                                }, 50);
                            } else {
                                console.log('MathJax ready but Page loading - waiting for DOMContentLoaded');
                            }
                        }
                    });
                }
            }
        };
    </script>
    <!-- Load MathJax from local copy to avoid network dependency -->
    <script id="MathJax-script" async src="../../js/vendor/mathjax-tex-mml-chtml.js"></script>
    <style>
        /* Tool Specific Styles */
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        body {
            display: grid;
            grid-template-rows: auto auto 1fr auto;
            /* navigation, controls, workspace, footer */
            height: 100vh;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        #navigation-container {
            flex-shrink: 0;
        }

        .controls {
            flex-shrink: 0;
        }

        .workspace {
            display: grid;
            grid-template-columns: 0.8fr 1.2fr;
            grid-template-rows: 1fr;
            gap: 15px;
            flex: 1;
            min-height: 0;
            padding: 5px 15px;
            overflow: hidden;
        }

        .editor-container.hidden,
        .preview-container.hidden {
            display: none;
        }

        .editor-container,
        .preview-container {
            display: flex;
            flex-direction: column;
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
        }

        .editor-wrapper {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .line-numbers {
            background: var(--bg-color);
            color: var(--text-secondary);
            padding: 15px 8px;
            font-family: var(--font-mono);
            font-size: 14px;
            line-height: 1.5;
            text-align: right;
            user-select: none;
            border-right: 1px solid var(--border-color);
            min-width: 50px;
            overflow: hidden;
        }

        .line-number {
            display: block;
            padding: 0 4px;
        }

        .line-number.error {
            color: rgba(255, 165, 0, 0.9);
            background: rgba(255, 165, 0, 0.15);
            font-weight: bold;
        }

        .editor-textarea-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        /* Controls Bar */
        .controls {
            background: var(--surface-color);
            border-bottom: 1px solid var(--border-color);
            padding: 8px 15px;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group-title {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-weight: 600;
            white-space: nowrap;
        }

        .control-select {
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .control-select:hover {
            border-color: var(--primary-color);
        }

        .control-select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(0, 255, 65, 0.1);
        }

        #style-selector,
        #font-selector {
            width: 140px;
            max-width: 140px;
        }

        /* Standardized Footer Overrides */
        .unified-footer {
            margin-top: 0 !important;
            padding: 1rem 0 !important;
            /* Slightly tighter for this complex tool */
            flex-shrink: 0;
            background: var(--surface-color) !important;
            border-top: 1px solid var(--border-color) !important;
            font-size: 0.85rem;
        }

        .control-divider {
            width: 1px;
            height: 30px;
            background: var(--border-color);
        }

        .checkbox-group {
            display: flex;
            gap: 12px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            color: var(--text-primary);
            user-select: none;
        }

        .checkbox-label input[type="checkbox"] {
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        .checkbox-label:hover {
            color: var(--primary-color);
        }

        .color-picker {
            width: 40px;
            height: 32px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-picker:hover {
            border-color: var(--primary-color);
        }

        .actions-group {
            margin-left: auto;
        }

        .btn {
            padding: 8px 16px;
            border: 1px solid var(--primary-color);
            background: transparent;
            color: var(--primary-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .btn:hover {
            background: var(--primary-color);
            color: #000;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 255, 65, 0.3);
        }

        .btn-primary {
            background: var(--primary-color);
            color: #000;
        }

        .btn-primary:hover {
            background: var(--primary-hover);
        }

        .btn-secondary {
            border-color: var(--text-secondary);
            color: var(--text-secondary);
        }

        .btn-secondary:hover {
            background: var(--text-secondary);
            color: #000;
        }

        @media (max-width: 1200px) {
            .controls {
                gap: 10px;
            }

            .control-group-title {
                display: none;
            }

            .actions-group {
                margin-left: 0;
                width: 100%;
                justify-content: center;
            }
        }

        .panel-header {
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-title {
            font-size: 0.9rem;
            font-weight: bold;
            color: var(--primary-color);
            text-transform: uppercase;
        }

        #markdown-input {
            width: 100%;
            height: 100%;
            background: var(--bg-color);
            color: var(--text-primary);
            border: none;
            padding: 15px;
            font-family: var(--font-mono);
            font-size: 14px;
            line-height: 1.5;
            resize: none;
            outline: none;
            overflow-y: auto;
            overflow-x: hidden;
        }

        #preview-output {
            flex: 1;
            background: white;
            color: black;
            padding: 25px 35px;
            overflow-y: auto;
            font-family: 'Times New Roman', serif;
            line-height: 1.6;
        }

        /* Markdown Content Styling */
        #preview-output p {
            margin: 1em 0;
        }

        #preview-output h1,
        #preview-output h2,
        #preview-output h3,
        #preview-output h4,
        #preview-output h5,
        #preview-output h6 {
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            font-weight: bold;
        }

        #preview-output h1 {
            font-size: 2em;
            border-bottom: 2px solid #eee;
            padding-bottom: 0.3em;
        }

        #preview-output h2 {
            font-size: 1.5em;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.3em;
        }

        #preview-output h3 {
            font-size: 1.25em;
        }

        #preview-output ul,
        #preview-output ol {
            margin: 1em 0;
            padding-left: 2em;
        }

        #preview-output li {
            margin: 0.5em 0;
        }

        #preview-output ul ul,
        #preview-output ol ol,
        #preview-output ul ol,
        #preview-output ol ul {
            margin-top: 0.5em;
            margin-bottom: 0.5em;
        }

        #preview-output blockquote {
            margin: 1em 0;
            padding: 0 1em;
            border-left: 4px solid #ddd;
            color: #666;
        }

        #preview-output hr {
            margin: 2em 0;
            border: none;
            border-top: 1px solid #eee;
        }

        #preview-output img {
            max-width: 100%;
            height: auto;
            margin: 1em 0;
        }

        #preview-output a {
            color: #0066cc;
            text-decoration: none;
        }

        #preview-output a:hover {
            text-decoration: underline;
        }

        /* MathJax Styling - Fix display issues */
        #preview-output .MathJax,
        #preview-output .MathJax_SVG {
            display: inline-block;
            max-width: 100%;
            overflow: visible;
        }

        /* MathJax display math (block formulas like $$...$$) */
        #preview-output .MathJax_Display,
        #preview-output .MathJax_SVG_Display {
            display: block;
            margin: 1.5em auto;
            text-align: center;
            width: auto;
            max-width: 100%;
        }

        /* Hide MathJax menu and context menu elements */
        #preview-output .MathJax_Menu,
        #preview-output .MathJax_MenuFrame,
        #preview-output .MathJax_MenuButton,
        #preview-output .MathJax_ContextMenu,
        #preview-output .MathJax_MenuCloseButton {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }

        /* Ensure MathJax SVG elements are properly styled */
        #preview-output .MathJax svg,
        #preview-output .MathJax_SVG svg {
            display: inline-block;
            vertical-align: middle;
            max-width: 100%;
            height: auto;
            border: none;
            background: transparent;
        }

        /* Fix any MathJax positioning issues */
        #preview-output .MathJax[style*="position"],
        #preview-output .MathJax_SVG[style*="position"] {
            position: static !important;
        }

        /* Controls */
        .controls {
            padding: 10px 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            background: var(--surface-color);
            border-bottom: 1px solid var(--border-color);
        }

        select {
            background: var(--bg-color);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 5px 10px;
            font-family: var(--font-mono);
            cursor: pointer;
        }

        /* PDF Styles Injection Targets */
        /* Style: Default (Academic-ish) */
        .style-default #preview-output {
            font-family: 'Times New Roman', serif;
            line-height: 1.6;
        }

        .style-default #preview-output h1 {
            border-bottom: 1px solid #ccc;
            padding-bottom: 10px;
        }

        /* Code coloring for Academic theme */
        .style-default #preview-output pre {
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 1em;
            overflow-x: auto;
            margin: 1em 0;
        }

        .style-default #preview-output .hljs {
            background: #f8f8f8;
            color: #333;
            padding: 1em;
        }

        .style-default #preview-output code {
            background: #f0f0f0;
            color: #c7254e;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }

        .style-default #preview-output pre code.hljs {
            background: transparent !important;
            padding: 0 !important;
            /* Let highlight.js classes set colors */
        }

        .style-default #preview-output pre code:not(.hljs) {
            background: transparent;
            color: inherit;
            padding: 0;
        }

        /* Style: Modern */
        .style-modern #preview-output {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        .style-modern #preview-output h1 {
            color: #2c3e50;
        }

        .style-modern #preview-output blockquote {
            border-left: 4px solid #3498db;
            padding-left: 15px;
            color: #7f8c8d;
        }

        /* Code coloring for Business theme */
        .style-modern #preview-output pre {
            background: #2d3748;
            border-radius: 6px;
            padding: 1em;
            overflow-x: auto;
            margin: 1em 0;
            border: 1px solid #4a5568;
        }

        .style-modern #preview-output .hljs {
            background: #2d3748;
            color: #e2e8f0;
            padding: 1em;
        }

        .style-modern #preview-output code {
            background: #edf2f7;
            color: #2d3748;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.9em;
            border: 1px solid #cbd5e0;
        }

        .style-modern #preview-output pre code.hljs {
            background: transparent !important;
            padding: 0 !important;
            border: none !important;
            /* Let highlight.js classes set colors */
        }

        .style-modern #preview-output pre code:not(.hljs) {
            background: transparent;
            color: inherit;
            padding: 0;
            border: none;
        }

        /* Style: Hacker */
        .style-hacker #preview-output {
            background: #0a0a0a !important;
            color: #00ff41 !important;
            font-family: 'Courier New', Courier, monospace;
        }

        .style-hacker #preview-output a {
            color: #00b8ff;
            text-decoration: underline;
        }

        .style-hacker #preview-output code {
            border: 1px solid #333;
            background: #111;
            padding: 2px 4px;
            font-family: 'Courier New', Courier, monospace;
        }

        .style-hacker #preview-output pre code.hljs {
            border: none !important;
            padding: 0 !important;
            background: transparent !important;
            /* Let highlight.js classes set colors */
        }

        .style-hacker #preview-output pre code:not(.hljs) {
            border: none;
            padding: 0;
        }

        /* Code coloring for Hacker theme */
        .style-hacker #preview-output pre {
            background: #0d1117 !important;
            border: 1px solid #30363d;
            border-radius: 4px;
            padding: 1em;
            overflow-x: auto;
            margin: 1em 0;
        }

        .style-hacker #preview-output .hljs {
            background: #0d1117 !important;
            color: #c9d1d9 !important;
            padding: 1em;
        }

        .style-hacker #preview-output .hljs-keyword {
            color: #ff7b72 !important;
        }

        .style-hacker #preview-output .hljs-string {
            color: #a5d6ff !important;
        }

        .style-hacker #preview-output .hljs-comment {
            color: #8b949e !important;
        }

        .style-hacker #preview-output .hljs-number {
            color: #79c0ff !important;
        }

        .style-hacker #preview-output .hljs-function {
            color: #d2a8ff !important;
        }

        /* Style: Minimal */
        .style-minimal #preview-output {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.8;
            color: #2c3e50;
            background: #fafafa;
        }

        .style-minimal #preview-output h1,
        .style-minimal #preview-output h2 {
            border: none;
            font-weight: 300;
            color: #1a1a1a;
        }

        .style-minimal #preview-output h1 {
            font-size: 2.5em;
            letter-spacing: -0.5px;
        }

        .style-minimal #preview-output blockquote {
            border-left: 3px solid #e0e0e0;
            padding-left: 20px;
            color: #666;
            font-style: italic;
        }

        .style-minimal #preview-output code {
            background: #f5f5f5;
            color: #e83e8c;
            padding: 2px 6px;
            border-radius: 3px;
        }

        /* Code coloring for Minimal theme */
        .style-minimal #preview-output pre {
            background: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 1em;
            overflow-x: auto;
            margin: 1em 0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .style-minimal #preview-output .hljs {
            background: #ffffff;
            color: #2c3e50;
            padding: 1em;
        }

        .style-minimal #preview-output .hljs-keyword {
            color: #e83e8c;
        }

        .style-minimal #preview-output .hljs-string {
            color: #28a745;
        }

        .style-minimal #preview-output .hljs-comment {
            color: #6c757d;
            font-style: italic;
        }

        .style-minimal #preview-output .hljs-number {
            color: #007bff;
        }

        .style-minimal #preview-output .hljs-function {
            color: #6f42c1;
        }

        .style-minimal #preview-output pre code.hljs {
            background: transparent !important;
            padding: 0 !important;
            /* Let highlight.js classes set colors */
        }

        .style-minimal #preview-output pre code:not(.hljs) {
            background: transparent;
            color: inherit;
            padding: 0;
        }

        /* Style: Dark */
        .style-dark #preview-output {
            background: #1e1e1e !important;
            color: #d4d4d4 !important;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .style-dark #preview-output h1,
        .style-dark #preview-output h2 {
            color: #ffffff;
            border-color: #404040;
        }

        .style-dark #preview-output a {
            color: #4ec9b0;
        }

        .style-dark #preview-output code {
            background: #252526;
            color: #ce9178;
            border: 1px solid #3e3e42;
        }

        /* Code coloring for Dark theme */
        .style-dark #preview-output pre {
            background: #1e1e1e !important;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 1em;
            overflow-x: auto;
            margin: 1em 0;
        }

        .style-dark #preview-output .hljs {
            background: #1e1e1e !important;
            color: #d4d4d4 !important;
            padding: 1em;
        }

        .style-dark #preview-output .hljs-keyword {
            color: #569cd6 !important;
        }

        .style-dark #preview-output .hljs-string {
            color: #ce9178 !important;
        }

        .style-dark #preview-output .hljs-comment {
            color: #6a9955 !important;
        }

        .style-dark #preview-output .hljs-number {
            color: #b5cea8 !important;
        }

        .style-dark #preview-output .hljs-function {
            color: #dcdcaa !important;
        }

        .style-dark #preview-output .hljs-variable {
            color: #9cdcfe !important;
        }

        .style-dark #preview-output pre code.hljs {
            background: transparent !important;
            padding: 0 !important;
            border: none !important;
            /* Let highlight.js classes set colors */
        }

        .style-dark #preview-output pre code:not(.hljs) {
            background: transparent;
            color: inherit;
            padding: 0;
            border: none;
        }

        .style-dark #preview-output blockquote {
            border-left-color: #007acc;
            color: #858585;
        }

        .style-dark #preview-output table {
            border-color: #404040;
        }

        .style-dark #preview-output th {
            background-color: #2d2d2d;
            color: #d4d4d4;
            border-color: #404040;
        }

        .style-dark #preview-output td {
            border-color: #404040;
            color: #d4d4d4;
        }

        .style-dark #preview-output tr:nth-child(even) {
            background-color: #252526;
        }

        .style-dark #preview-output tr:hover {
            background-color: #2a2d2e;
        }

        /* Style: Colorful */
        .style-colorful #preview-output {
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Comic Neue', cursive;
            line-height: 1.7;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            background: #fff5f5;
        }

        .style-colorful #preview-output h1 {
            color: #e53e3e;
            border-bottom: 3px solid #fc8181;
        }

        .style-colorful #preview-output h2 {
            color: #3182ce;
            border-bottom: 2px solid #90cdf4;
        }

        .style-colorful #preview-output h3 {
            color: #38a169;
        }

        .style-colorful #preview-output a {
            color: #805ad5;
        }

        .style-colorful #preview-output blockquote {
            border-left: 4px solid #f6ad55;
            background: #fffaf0;
            padding: 10px 20px;
            border-radius: 4px;
        }

        .style-colorful #preview-output code {
            background: #fed7d7;
            color: #c53030;
            padding: 2px 6px;
            border-radius: 3px;
        }

        /* Code coloring for Colorful theme */
        .style-colorful #preview-output pre {
            background: #2d3748;
            border: 2px solid #4299e1;
            border-radius: 8px;
            padding: 1em;
            overflow-x: auto;
            margin: 1em 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .style-colorful #preview-output .hljs {
            background: #2d3748;
            color: #f7fafc;
            padding: 1em;
        }

        .style-colorful #preview-output .hljs-keyword {
            color: #fc8181 !important;
        }

        .style-colorful #preview-output .hljs-string {
            color: #68d391 !important;
        }

        .style-colorful #preview-output .hljs-comment {
            color: #f6ad55 !important;
            font-style: italic;
        }

        .style-colorful #preview-output .hljs-number {
            color: #63b3ed !important;
        }

        .style-colorful #preview-output .hljs-function {
            color: #b794f4 !important;
        }

        .style-colorful #preview-output .hljs-variable {
            color: #fbb6ce !important;
        }

        .style-colorful #preview-output pre code.hljs {
            background: transparent !important;
            padding: 0 !important;
            /* Let highlight.js classes set colors */
        }

        .style-colorful #preview-output pre code:not(.hljs) {
            background: transparent;
            color: inherit;
            padding: 0;
        }

        /* Style: Professional */
        .style-professional #preview-output {
            font-family: 'Georgia', 'Times New Roman', serif;
            line-height: 1.75;
            color: #1a1a1a;
            background: #ffffff;
            max-width: 800px;
            margin: 0 auto;
        }

        .style-professional #preview-output h1 {
            font-size: 2.25em;
            color: #1a365d;
            border-bottom: 3px solid #2c5282;
            padding-bottom: 0.5em;
            margin-bottom: 0.5em;
        }

        .style-professional #preview-output h2 {
            font-size: 1.75em;
            color: #2c5282;
            border-bottom: 2px solid #4299e1;
            padding-bottom: 0.3em;
        }

        .style-professional #preview-output h3 {
            color: #2d3748;
            font-size: 1.35em;
        }

        .style-professional #preview-output blockquote {
            border-left: 4px solid #4299e1;
            padding-left: 20px;
            margin-left: 0;
            color: #4a5568;
            font-style: italic;
            background: #edf2f7;
            padding: 15px 20px;
            border-radius: 4px;
        }

        .style-professional #preview-output code {
            background: #f7fafc;
            color: #2d3748;
            border: 1px solid #e2e8f0;
            padding: 2px 6px;
            border-radius: 3px;
        }

        /* Code coloring for Professional theme */
        .style-professional #preview-output pre {
            background: #1a202c;
            border: 2px solid #2d3748;
            border-radius: 6px;
            padding: 1.25em;
            overflow-x: auto;
            margin: 1.5em 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .style-professional #preview-output .hljs {
            background: #1a202c;
            color: #e2e8f0;
            padding: 1.25em;
        }

        .style-professional #preview-output .hljs-keyword {
            color: #90cdf4 !important;
            font-weight: 600;
        }

        .style-professional #preview-output .hljs-string {
            color: #9ae6b4 !important;
        }

        .style-professional #preview-output .hljs-comment {
            color: #a0aec0 !important;
            font-style: italic;
        }

        .style-professional #preview-output .hljs-number {
            color: #fbb6ce !important;
        }

        .style-professional #preview-output .hljs-function {
            color: #d6bcfa !important;
        }

        .style-professional #preview-output .hljs-variable {
            color: #fbd38d !important;
        }

        .style-professional #preview-output .hljs-title {
            color: #81e6d9 !important;
        }

        .style-professional #preview-output pre code.hljs {
            background: transparent !important;
            padding: 0 !important;
            border: none !important;
            /* Let highlight.js classes set colors */
        }

        .style-professional #preview-output pre code:not(.hljs) {
            background: transparent;
            color: inherit;
            padding: 0;
            border: none;
        }

        .style-professional #preview-output table {
            border: 2px solid #e2e8f0;
        }

        .style-professional #preview-output th {
            background: #2c3e50;
            color: white;
            font-weight: 600;
        }

        .style-professional #preview-output td {
            border-color: #e2e8f0;
        }

        /* Font Classes - Independent from themes */
        .font-yahei #preview-output {
            font-family: 'Microsoft YaHei', '微软雅黑', sans-serif !important;
        }

        .font-simsun #preview-output {
            font-family: 'SimSun', '宋体', serif !important;
        }

        .font-kaiti #preview-output {
            font-family: 'KaiTi', '楷体', serif !important;
        }

        .font-simhei #preview-output {
            font-family: 'SimHei', '黑体', sans-serif !important;
        }

        .font-fangsong #preview-output {
            font-family: 'FangSong', '仿宋', serif !important;
        }

        .font-pingfang #preview-output {
            font-family: 'PingFang SC', '苹方', sans-serif !important;
        }

        .font-noto #preview-output {
            font-family: 'Noto Sans SC', '思源黑体', sans-serif !important;
        }

        .font-noto-serif #preview-output {
            font-family: 'Noto Serif SC', '思源宋体', serif !important;
        }

        .font-wenquanyi #preview-output {
            font-family: 'WenQuanYi Micro Hei', '文泉驿微米黑', sans-serif !important;
        }

        .font-stheiti #preview-output {
            font-family: 'STHeiti', '华文黑体', sans-serif !important;
        }

        .font-stsong #preview-output {
            font-family: 'STSong', '华文宋体', serif !important;
        }

        .font-stkaiti #preview-output {
            font-family: 'STKaiti', '华文楷体', serif !important;
        }

        .font-arial #preview-output {
            font-family: 'Arial', sans-serif !important;
        }

        .font-times #preview-output {
            font-family: 'Times New Roman', serif !important;
        }

        .font-courier #preview-output {
            font-family: 'Courier New', monospace !important;
        }

        .font-georgia #preview-output {
            font-family: 'Georgia', serif !important;
        }

        .font-verdana #preview-output {
            font-family: 'Verdana', sans-serif !important;
        }

        /* General Code Block Styling - Fallback for themes without specific styles */
        #preview-output pre {
            background: #282c34;
            border-radius: 6px;
            padding: 1em;
            overflow-x: auto;
            margin: 1em 0;
            font-family: 'SF Mono', 'Menlo', 'Monaco', 'Courier New', monospace;
        }

        #preview-output code {
            font-family: 'SF Mono', 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
        }

        /* Highlight.js styles - ensure they have high priority */
        /* Don't override color for highlighted code - let highlight.js handle it */
        #preview-output pre code.hljs {
            background: transparent !important;
            padding: 0 !important;
            /* Don't set color: inherit here - let highlight.js classes set colors */
        }

        /* Ensure highlight.js default styles are not overridden */
        /* The atom-one-dark theme CSS should provide base colors */
        /* We ensure our styles don't override highlight.js colors */

        /* CRITICAL: Do NOT set color: inherit on .hljs children - this breaks highlighting */
        /* Let highlight.js CSS (atom-one-dark.min.css) handle all syntax colors */

        /* Ensure highlight.js classes are visible - Fallback */
        #preview-output .hljs {
            background: #282c34;
            color: #abb2bf;
            display: block;
            overflow-x: auto;
            padding: 1em;
        }

        /* Common highlight.js syntax colors - used as fallback with high priority */
        #preview-output .hljs-keyword {
            color: #c678dd !important;
        }

        #preview-output .hljs-string {
            color: #98c379 !important;
        }

        #preview-output .hljs-comment {
            color: #5c6370 !important;
            font-style: italic;
        }

        #preview-output .hljs-number {
            color: #d19a66 !important;
        }

        #preview-output .hljs-function {
            color: #61afef !important;
        }

        #preview-output .hljs-variable {
            color: #e06c75 !important;
        }

        /* Ensure all highlight.js syntax classes are visible */
        #preview-output .hljs-title,
        #preview-output .hljs-built_in,
        #preview-output .hljs-type {
            color: #e5c07b !important;
        }

        #preview-output .hljs-literal {
            color: #56b6c2 !important;
        }

        #preview-output .hljs-attr,
        #preview-output .hljs-attribute {
            color: #d19a66 !important;
        }

        #preview-output .hljs-meta {
            color: #c678dd !important;
        }

        #preview-output .hljs-tag {
            color: #e06c75 !important;
        }

        /* Table Styling */
        #preview-output table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
            border: 1px solid #ddd;
        }

        #preview-output th,
        #preview-output td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: left;
        }

        #preview-output th {
            background-color: #f4f4f4;
            font-weight: bold;
        }

        #preview-output tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        #preview-output tr:hover {
            background-color: #f5f5f5;
        }

        /* Hacker theme table styling */
        .style-hacker #preview-output table {
            border: 1px solid #333;
        }

        .style-hacker #preview-output th,
        .style-hacker #preview-output td {
            border: 1px solid #333;
            color: #00ff41;
        }

        .style-hacker #preview-output th {
            background-color: #111;
        }

        .style-hacker #preview-output tr:nth-child(even) {
            background-color: #0a0a0a;
        }

        .style-hacker #preview-output tr:hover {
            background-color: #1a1a1a;
        }

        /* Print Media Query */
        /* Hide page headers and footers in print (Chrome/Safari) */
        @page {
            margin: 0;
        }

        @media print {

            /* Hide everything except preview output */
            body * {
                visibility: hidden;
            }

            #preview-output,
            #preview-output * {
                visibility: visible;
            }

            /* Ensure preview output takes full page */
            #preview-output {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                margin: 0;
                padding: 40px !important;
                /* Match preview padding */
                /* Preserve all styles from preview - use computed styles */
                background: inherit !important;
                color: inherit !important;
                font-family: inherit !important;
                line-height: inherit !important;
            }

            /* Preserve theme styles in print - use exact styles from preview */
            .style-default #preview-output {
                background: white !important;
                color: black !important;
                font-family: 'Times New Roman', serif !important;
            }

            .style-modern #preview-output {
                background: white !important;
                color: #333 !important;
                font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif !important;
            }

            /* Force background colors for hacker theme printing if selected */
            .style-hacker #preview-output {
                background-color: #0a0a0a !important;
                color: #00ff41 !important;
                font-family: 'Courier New', Courier, monospace !important;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }

            .style-minimal #preview-output {
                background: #fafafa !important;
                color: #2c3e50 !important;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif !important;
            }

            .style-dark #preview-output {
                background: #1e1e1e !important;
                color: #d4d4d4 !important;
                font-family: 'Consolas', 'Monaco', monospace !important;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
                border-right: none !important;
                /* Fix potential white border */
            }

            /* Ensure page background is dark for dark theme */
            .style-dark #preview-output::before {
                content: "";
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: #1e1e1e !important;
                z-index: -1;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }

            .style-colorful #preview-output {
                background: #fff5f5 !important;
                color: #333 !important;
                font-family: 'Comic Sans MS', 'Chalkboard SE', 'Comic Neue', cursive !important;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }

            /* Preserve code block styles - don't use inherit, preserve actual styles */
            #preview-output pre {
                padding: 1em !important;
                overflow: visible !important;
                /* Allow code to wrap in print */
                page-break-inside: avoid !important;
                /* Background and border will be set by theme-specific rules below */
            }

            #preview-output code {
                padding: 2px 4px !important;
                border-radius: 3px !important;
                /* Background and color will be set by theme-specific rules below */
            }

            /* Preserve highlight.js container styles - use actual computed styles */
            #preview-output .hljs {
                padding: 1em !important;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
                /* Background and color will be set by theme-specific rules below */
            }

            /* Force color printing for ALL highlight.js syntax classes */
            /* This ensures all syntax highlighting colors are preserved in print */
            #preview-output .hljs-keyword,
            #preview-output .hljs-string,
            #preview-output .hljs-comment,
            #preview-output .hljs-number,
            #preview-output .hljs-function,
            #preview-output .hljs-variable,
            #preview-output .hljs-title,
            #preview-output .hljs-built_in,
            #preview-output .hljs-type,
            #preview-output .hljs-literal,
            #preview-output .hljs-attr,
            #preview-output .hljs-attribute,
            #preview-output .hljs-meta,
            #preview-output .hljs-tag,
            #preview-output .hljs-name,
            #preview-output .hljs-selector-id,
            #preview-output .hljs-selector-class,
            #preview-output .hljs-regexp,
            #preview-output .hljs-link,
            #preview-output .hljs-symbol,
            #preview-output .hljs-params,
            #preview-output .hljs-property,
            #preview-output .hljs-class,
            #preview-output .hljs-subst,
            #preview-output .hljs-doctag,
            #preview-output .hljs-section,
            #preview-output .hljs-emphasis,
            #preview-output .hljs-strong,
            #preview-output .hljs-addition,
            #preview-output .hljs-deletion {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
                /* Colors are set by highlight.js CSS and theme overrides - preserve them */
            }

            /* Theme-specific code block styles for print */
            /* Default/Academic theme */
            .style-default #preview-output pre,
            .style-default #preview-output .hljs {
                background: #f8f8f8 !important;
                color: #333 !important;
                border: 1px solid #e0e0e0 !important;
            }

            /* Modern/Business theme */
            .style-modern #preview-output pre,
            .style-modern #preview-output .hljs {
                background: #2d3748 !important;
                color: #e2e8f0 !important;
                border: 1px solid #4a5568 !important;
            }

            /* Hacker theme */
            .style-hacker #preview-output pre,
            .style-hacker #preview-output .hljs {
                background: #0d1117 !important;
                color: #c9d1d9 !important;
                border: 1px solid #30363d !important;
            }

            /* Minimal theme */
            .style-minimal #preview-output pre,
            .style-minimal #preview-output .hljs {
                background: #ffffff !important;
                color: #2c3e50 !important;
                border: 1px solid #e0e0e0 !important;
            }

            /* Dark theme */
            .style-dark #preview-output pre,
            .style-dark #preview-output .hljs {
                background: #1e1e1e !important;
                color: #d4d4d4 !important;
                border: 1px solid #3e3e42 !important;
            }

            /* Colorful theme */
            .style-colorful #preview-output pre,
            .style-colorful #preview-output .hljs {
                background: #2d3748 !important;
                color: #f7fafc !important;
                border: 2px solid #4299e1 !important;
            }

            /* Professional theme */
            .style-professional #preview-output pre,
            .style-professional #preview-output .hljs {
                background: #1a202c !important;
                color: #e2e8f0 !important;
                border: 1px solid #2d3748 !important;
            }

            /* Preserve table styles */
            #preview-output table {
                border-collapse: collapse !important;
                width: 100% !important;
                margin: 1em 0 !important;
                page-break-inside: avoid !important;
            }

            #preview-output th,
            #preview-output td {
                border: 1px solid #ddd !important;
                padding: 8px 12px !important;
            }

            #preview-output th {
                background: #f4f4f4 !important;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }

            /* Preserve blockquote styles */
            #preview-output blockquote {
                border-left: 4px solid #ddd !important;
                padding-left: 20px !important;
                margin: 1em 0 !important;
                color: #666 !important;
            }

            /* Preserve heading styles */
            #preview-output h1,
            #preview-output h2,
            #preview-output h3,
            #preview-output h4,
            #preview-output h5,
            #preview-output h6 {
                margin-top: 1.5em !important;
                margin-bottom: 0.5em !important;
                font-weight: bold !important;
                page-break-after: avoid !important;
            }

            #preview-output h1 {
                font-size: 2em !important;
                border-bottom: 2px solid #eee !important;
                padding-bottom: 0.3em !important;
            }

            #preview-output h2 {
                font-size: 1.5em !important;
                border-bottom: 1px solid #eee !important;
                padding-bottom: 0.3em !important;
            }

            /* Preserve image styles */
            #preview-output img {
                max-width: 100% !important;
                height: auto !important;
                margin: 1em 0 !important;
                page-break-inside: avoid !important;
            }

            /* Preserve link styles */
            #preview-output a {
                color: #0066cc !important;
                text-decoration: none !important;
            }

            /* Hide link URLs in print - only show link text */
            #preview-output a[href]::after {
                content: "" !important;
                display: none !important;
            }

            /* Preserve list styles */
            #preview-output ul,
            #preview-output ol {
                margin: 1em 0 !important;
                padding-left: 2em !important;
            }

            #preview-output li {
                margin: 0.5em 0 !important;
            }

            /* Preserve horizontal rule styles */
            #preview-output hr {
                margin: 2em 0 !important;
                border: none !important;
                border-top: 1px solid #eee !important;
            }

            /* Preserve paragraph styles */
            #preview-output p {
                margin: 1em 0 !important;
            }

            /* Ensure Mermaid diagrams are properly sized and don't overlap */
            #preview-output .mermaid {
                display: block !important;
                width: 100% !important;
                max-width: 100% !important;
                margin: 2em 0 !important;
                padding: 1em 0 !important;
                page-break-inside: avoid !important;
                page-break-after: auto !important;
                overflow: hidden !important;
                box-sizing: border-box !important;
            }

            #preview-output .mermaid svg {
                max-width: 700px !important;
                /* Limit width considering page margins */
                width: 100% !important;
                height: auto !important;
                max-height: 500px !important;
                /* Limit height to prevent overlap with next content */
                display: block !important;
                margin: 0 auto !important;
                page-break-inside: avoid !important;
                box-sizing: border-box !important;
                overflow: visible !important;
            }

            /* Ensure all Mermaid SVG elements don't overflow (for all diagram types) */
            #preview-output svg {
                max-width: 700px !important;
                /* Limit width for any SVG in print */
                width: 100% !important;
                height: auto !important;
                max-height: 500px !important;
                /* Limit height to prevent overlap */
                display: block !important;
                margin: 0 auto !important;
                page-break-inside: avoid !important;
                overflow: visible !important;
                box-sizing: border-box !important;
            }

            /* Ensure Mermaid containers don't cause overflow */
            #preview-output .mermaid>div,
            #preview-output .mermaid>span {
                max-width: 100% !important;
                overflow: hidden !important;
                display: block !important;
            }

            /* Ensure content after Mermaid diagrams has proper spacing */
            #preview-output .mermaid+* {
                margin-top: 2em !important;
                page-break-before: auto !important;
            }

            /* Ensure MathJax formulas are visible and properly styled */
            #preview-output .MathJax,
            #preview-output .MathJax_SVG,
            #preview-output .MathJax_Display,
            #preview-output .MathJax_SVG_Display {
                display: block !important;
                page-break-inside: avoid !important;
                max-width: 100% !important;
                overflow: visible !important;
                margin: 1em 0 !important;
                text-align: center !important;
            }

            /* Hide MathJax menu and other UI elements */
            #preview-output .MathJax_Menu,
            #preview-output .MathJax_MenuFrame,
            #preview-output .MathJax_MenuButton,
            #preview-output .MathJax_ContextMenu {
                display: none !important;
                visibility: hidden !important;
            }

            /* Ensure MathJax SVG elements don't have unwanted borders or backgrounds */
            #preview-output .MathJax svg,
            #preview-output .MathJax_SVG svg {
                display: inline-block !important;
                vertical-align: middle !important;
                max-width: 100% !important;
                height: auto !important;
                border: none !important;
                background: transparent !important;
            }

            /* Fix MathJax display math (block formulas) */
            #preview-output .MathJax_Display,
            #preview-output .MathJax_SVG_Display {
                display: block !important;
                margin: 1.5em auto !important;
                text-align: center !important;
                width: auto !important;
                max-width: 100% !important;
            }

            /* Hide Chrome's automatic page URL in footer */
            @page {
                margin: 0.5in;
                size: auto;
            }

            /* Additional attempt to hide page headers/footers */
            html,
            body {
                margin: 0 !important;
                padding: 0 !important;
                height: auto !important;
                overflow: visible !important;
            }
        }

        @media (max-width: 768px) {
            .workspace {
                grid-template-columns: 1fr;
                min-height: 0;
            }

            #markdown-input,
            #preview-output {
                min-height: 400px;
            }

            /* On mobile, ensure visibility controls work properly */
            .editor-container.hidden,
            .preview-container.hidden {
                display: none !important;
            }
        }

        /* Mobile Friendly PDF Styles */
        /* Mobile Friendly PDF Mode (Applied to Screen & Print) */
        .mobile-pdf-mode {
            /* Larger base font size for readability */
            font-size: 18pt !important;
            line-height: 1.6 !important;
            /* Maximize width */
            width: 100% !important;
            max-width: 100% !important;
            padding: 20px !important;
            /* Add padding for screen view */
            margin: 0 !important;
        }

        .mobile-pdf-mode h1 {
            font-size: 24pt !important;
            margin-top: 1em !important;
            margin-bottom: 0.8em !important;
        }

        .mobile-pdf-mode h2 {
            font-size: 20pt !important;
            margin-top: 1.2em !important;
            margin-bottom: 0.8em !important;
        }

        .mobile-pdf-mode h3 {
            font-size: 18pt !important;
            margin-top: 1.2em !important;
            margin-bottom: 0.6em !important;
        }

        .mobile-pdf-mode p,
        .mobile-pdf-mode li,
        .mobile-pdf-mode table {
            font-size: 18pt !important;
        }

        .mobile-pdf-mode pre {
            padding: 1em !important;
            margin: 1.5em 0 !important;
            white-space: pre-wrap !important;
            word-break: break-all !important;
        }

        .mobile-pdf-mode code {
            font-size: 16pt !important;
            font-family: 'Courier New', monospace !important;
        }

        @media print {
            .mobile-pdf-mode {
                padding: 0 !important;
                /* Reset padding for print */
            }

            /* Remove margins from page rule when this class is active */
            body.mobile-pdf-mode-active {
                margin: 0 !important;
            }
        }

        /* Remove margins from page rule when this class is active */
        /* Note: @page margins are controlled by browser print dialog largely, but this helps content flow */
        body.mobile-pdf-mode-active {
            margin: 0 !important;
        }

        /* Watermark Styles */
        .watermark-container {
            position: fixed;
            z-index: 9999;
            pointer-events: none;
            user-select: none;
        }

        .watermark-footer {
            bottom: 20px;
            right: 20px;
            font-size: 10pt;
            color: rgba(128, 128, 128, 0.5);
            font-family: sans-serif;
        }

        .watermark-full {
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-wrap: wrap;
            align-content: space-evenly;
            justify-content: space-evenly;
            background: transparent;
            pointer-events: none;
            overflow: hidden;
        }

        .watermark-tile {
            transform: rotate(-30deg);
            font-size: 20pt;
            color: rgba(128, 128, 128, 0.12);
            font-family: sans-serif;
            white-space: nowrap;
            user-select: none;
            /* 3 columns roughly */
            flex: 0 0 33%;
            height: 15vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Ensure watermark prints on every page */
        @media print {
            .watermark-container {
                position: fixed;
                top: 0;
                left: 0;
                height: 100vh;
                width: 100vw;
                z-index: 9999;
                display: block !important;
            }
        }

        /* Ensure watermark prints on every page */
        @media print {
            .watermark-container {
                position: fixed;
                /* Fixed position repeats on every page in most browsers */
                display: block !important;
            }
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background-color: var(--surface-color);
            margin: 10% auto;
            padding: 0;
            border: 1px solid var(--border-color);
            width: 80%;
            max-width: 600px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            margin: 0;
            color: var(--primary-color);
        }

        .close-modal {
            color: var(--text-secondary);
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-modal:hover {
            color: var(--primary-color);
        }

        .modal-body {
            padding: 20px;
        }

        .modal-footer {
            padding: 15px 20px;
            border-top: 1px solid var(--border-color);
            text-align: right;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }


        #toc-preview {
            margin: 0;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.85rem;
            color: var(--text-primary);
        }

        /* Syntax Error Tooltip */
        .line-number {
            position: relative;
        }

        .line-number.error {
            cursor: help;
        }

        .line-number-error-tooltip {
            position: fixed;
            padding: 8px 12px;
            background: rgba(255, 165, 0, 0.98);
            color: #000;
            border: 2px solid rgba(255, 165, 0, 0.8);
            border-radius: 4px;
            font-size: 0.75rem;
            white-space: pre-wrap;
            max-width: 300px;
            min-width: 200px;
            word-wrap: break-word;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 99999;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            line-height: 1.4;
        }

        .line-number.error:hover .line-number-error-tooltip,
        .line-number.error:active .line-number-error-tooltip {
            opacity: 1;
        }

        /* Range Slider */
        input[type=range] {
            width: 100%;
            margin: 10px 0;
            background: transparent;
            -webkit-appearance: none;
            appearance: none;
        }

        input[type=range]:focus {
            outline: none;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: var(--border-color);
            border-radius: 3px;
        }

        input[type=range]::-webkit-slider-thumb {
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -5px;
            box-shadow: 0 0 5px rgba(0, 255, 65, 0.5);
        }

        /* Compact Footer for Full-screen Workspace */
        .unified-footer {
            margin-top: 0 !important;
            padding: 1rem 0 !important;
            flex-shrink: 0;
        }
    </style>
</head>

<body>
    <!-- Navigation -->
    <div id="navigation-container"></div>
    <script>
        // Load Navigation synchronously to prevent page flash/jitter
        (function () {
            const xhr = new XMLHttpRequest();
            xhr.open('GET', '../../navigation.html', false); // Synchronous to prevent flash
            try {
                xhr.send();
                if (xhr.status === 200 || xhr.status === 0) { // 0 for file:// protocol
                    const container = document.getElementById('navigation-container');
                    container.innerHTML = xhr.responseText;

                    // Manually execute scripts from the loaded HTML
                    const scripts = container.querySelectorAll('script');
                    scripts.forEach(oldScript => {
                        const newScript = document.createElement('script');
                        // Copy attributes
                        Array.from(oldScript.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value));
                        // Copy content
                        newScript.textContent = oldScript.textContent;
                        document.body.appendChild(newScript);
                    });
                }
            } catch (e) {
                console.error('Failed to load navigation:', e);
            }
        })();
    </script>

    <!-- Controls Bar -->
    <div class="controls">
        <!-- Visibility Controls -->
        <div class="control-group">
            <div class="checkbox-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="show-input" onchange="toggleInputVisibility()" checked>
                    <span data-i18n="show_input">输入区域</span>
                </label>
                <label class="checkbox-label">
                    <input type="checkbox" id="show-preview" onchange="togglePreviewVisibility()" checked>
                    <span data-i18n="show_preview">预览区域</span>
                </label>
                <label class="checkbox-label">
                    <input type="checkbox" id="sync-scroll" onchange="toggleSyncScroll()" checked>
                    <span data-i18n="sync_scroll">同步滚动</span>
                </label>
            </div>
        </div>

        <div class="control-divider"></div>

        <!-- Style Settings Group -->
        <div class="control-group">
            <select id="style-selector" onchange="changeStyle()" class="control-select">
                <option value="style-default" data-i18n="style_academic">Academic</option>
                <option value="style-modern" data-i18n="style_business">Business</option>
                <option value="style-hacker" data-i18n="style_hacker">Hacker</option>
                <option value="style-minimal">Minimal</option>
                <option value="style-dark">Dark</option>
                <option value="style-colorful">Colorful</option>
                <option value="style-professional">Professional</option>
            </select>
        </div>

        <div class="control-divider"></div>

        <!-- Typography Group -->
        <div class="control-group">
            <select id="font-selector" onchange="changeFont()" class="control-select">
                <option value="'Microsoft YaHei', '微软雅黑', sans-serif" data-i18n="font_yahei">微软雅黑 (Microsoft YaHei)
                </option>
                <option value="'SimSun', '宋体', serif" data-i18n="font_simsun">宋体 (SimSun)</option>
                <option value="'KaiTi', '楷体', serif" data-i18n="font_kaiti">楷体 (KaiTi)</option>
                <option value="'SimHei', '黑体', sans-serif" data-i18n="font_simhei">黑体 (SimHei)</option>
                <option value="'FangSong', '仿宋', serif" data-i18n="font_fangsong">仿宋 (FangSong)</option>
                <option value="'PingFang SC', '苹方', sans-serif" data-i18n="font_pingfang">苹方 (PingFang SC)</option>
                <option value="'Noto Sans SC', '思源黑体', sans-serif" data-i18n="font_noto">思源黑体 (Noto Sans SC)</option>
                <option value="'Noto Serif SC', '思源宋体', serif" data-i18n="font_noto_serif">思源宋体 (Noto Serif SC)</option>
                <option value="'WenQuanYi Micro Hei', '文泉驿微米黑', sans-serif" data-i18n="font_wenquanyi">文泉驿微米黑
                    (WenQuanYi)</option>
                <option value="'STHeiti', '华文黑体', sans-serif" data-i18n="font_stheiti">华文黑体 (STHeiti)</option>
                <option value="'STSong', '华文宋体', serif" data-i18n="font_stsong">华文宋体 (STSong)</option>
                <option value="'STKaiti', '华文楷体', serif" data-i18n="font_stkaiti">华文楷体 (STKaiti)</option>
                <option value="'Arial', sans-serif" data-i18n="font_arial">Arial</option>
                <option value="'Times New Roman', serif" data-i18n="font_times">Times New Roman</option>
                <option value="'Courier New', monospace" data-i18n="font_courier">Courier New</option>
                <option value="'Georgia', serif" data-i18n="font_georgia">Georgia</option>
                <option value="'Verdana', sans-serif" data-i18n="font_verdana">Verdana</option>
            </select>
        </div>

        <div class="control-divider"></div>

        <!-- Features Group -->
        <div class="control-group">
            <div class="checkbox-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="enable-mermaid" onchange="updatePreview(true)" checked>
                    <span>Mermaid</span>
                </label>
                <label class="checkbox-label">
                    <input type="checkbox" id="enable-latex" onchange="updatePreview(true)" checked>
                    <span>LaTeX</span>
                </label>
            </div>
        </div>

        <div class="control-divider"></div>

        <div class="control-divider"></div>

        <!-- Advanced Settings (Collapsible) -->
        <!-- Background Color -->
        <div class="control-group">
            <label class="checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="enable-bg-color" onchange="changeBgColor()">
                <span data-i18n="enable_bg_color">自定义背景</span>
            </label>
            <input type="color" id="bg-color" value="#ffffff" onchange="changeBgColor()" class="color-picker"
                style="margin-left: 8px; opacity: 0.5;" disabled>
        </div>

        <div class="control-divider"></div>

        <!-- Watermark -->
        <div class="control-group">
            <div style="display: flex; flex-direction: column; gap: 8px; width: 100%;">
                <label class="checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                    <input type="checkbox" id="enable-watermark" onchange="updateWatermark()">
                    <span data-i18n="enable_watermark">PDF Watermark</span>
                </label>

                <div id="watermark-controls"
                    style="display: none; flex-direction: column; gap: 8px; padding-left: 20px;">
                    <input type="text" id="watermark-text" value="Created with Markdown2PDF" oninput="updateWatermark()"
                        style="width: 100%; padding: 4px; background: var(--bg-color); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-size: 0.9rem;">

                    <select id="watermark-type" onchange="updateWatermark()"
                        style="width: 100%; padding: 4px; background: var(--bg-color); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-size: 0.9rem;">
                        <option value="footer" data-i18n="watermark_type_footer">Footer (Bottom Right)</option>
                        <option value="full" data-i18n="watermark_type_full">Full Page (Diagonal)</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="control-divider"></div>

        <!-- ToC Generation -->
        <div class="control-group">
            <span class="control-group-title" data-i18n="toc_level_label">Level</span>
            <div style="display: flex; align-items: center; gap: 4px;">
                <button class="btn" onclick="decreaseTocLevel()"
                    style="padding: 4px 8px; font-size: 0.9rem;">⬇️</button>
                <input type="number" id="toc-levels" value="3" min="1" max="10"
                    style="width: 50px; text-align: center; padding: 4px; background: var(--bg-color); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px; font-size: 0.9rem;"
                    onchange="validateTocLevel()">
                <button class="btn" onclick="increaseTocLevel()"
                    style="padding: 4px 8px; font-size: 0.9rem;">⬆️</button>
            </div>
            <label class="checkbox-label"
                style="display: flex; align-items: center; gap: 4px; cursor: pointer; font-size: 0.8rem; margin-left: 8px;">
                <input type="checkbox" id="toc-insert" onchange="handleTocInsertChange()"
                    style="width: 16px; height: 16px; cursor: pointer;">
                <span data-i18n="toc_insert_label" style="white-space: nowrap;">插入目录</span>
            </label>
            <label class="checkbox-label"
                style="display: flex; align-items: center; gap: 4px; cursor: pointer; font-size: 0.8rem; margin-left: 8px;">
                <input type="checkbox" id="export-auto-title" onchange="debouncedUpdateToc()" checked
                    style="width: 16px; height: 16px; cursor: pointer;">
                <span data-i18n="export_auto_title" style="white-space: nowrap;">自动填写文件标题</span>
            </label>
        </div>

        <div class="control-divider"></div>

        <!-- Export Actions Group -->
        <div class="control-group actions-group">
            <select id="export-format" class="control-select" onchange="updateExportMode()">
                <option value="md">.md</option>
                <option value="html">.html</option>
                <option value="docx">.docx</option>

                <option value="pdf" selected>.pdf</option>
                <option value="pdf-mobile" data-i18n="pdf_mobile">.pdf (Mobile Friendly)</option>
            </select>
            <button class="btn btn-primary" onclick="handleExport()" data-i18n="export_button">导出</button>
        </div>
    </div>

    <!-- Workspace -->
    <div class="workspace" id="workspace">
        <div class="editor-container">
            <div class="panel-header">
                <span class="panel-title" data-i18n="panel_input_title">Markdown Input</span>
            </div>
            <div class="editor-wrapper">
                <div class="line-numbers" id="line-numbers"></div>
                <div class="editor-textarea-wrapper">
                    <textarea id="markdown-input" data-i18n-placeholder="input_placeholder"
                        placeholder="Type your markdown here..."># Hello World

This is a sample markdown document.

## Features

- Real-time preview
- PDF export
- Syntax highlighting
- Mermaid diagrams
- LaTeX support

```python
print("Hello World")
```

## Table of Contents

Click the button to generate a ToC!
</textarea>
                </div>
            </div>
        </div>
        <div class="preview-container">
            <div class="panel-header">
                <span class="panel-title" data-i18n="panel_preview_title">Preview</span>
            </div>
            <div id="preview-output"></div>
        </div>
    </div>

    <script>
        // Navigation is already loaded, just ensure language is applied
        if (typeof applyLanguage === 'function') {
            applyLanguage(localStorage.getItem('lang') || 'zh');
        }

        // Markdown Logic
        const input = document.getElementById('markdown-input');
        const output = document.getElementById('preview-output');
        const workspace = document.getElementById('workspace');

        // Initialize Mermaid
        let mermaidInitialized = false;
        if (window.mermaid) {
            mermaid.initialize({
                startOnLoad: false,
                theme: 'dark',
                securityLevel: 'loose'
            });
            mermaidInitialized = true;
        }

        // Verify highlight.js is loaded
        // Since script is loaded synchronously, it should be available immediately
        // But we'll also check on DOMContentLoaded as a fallback
        function checkHighlightJS() {
            if (window.hljs && typeof window.hljs.highlightElement === 'function') {
                console.log('✅ highlight.js loaded successfully');
                return true;
            }
            return false;
        }

        // Check immediately
        if (!checkHighlightJS()) {
            // If not loaded, wait for DOMContentLoaded
            document.addEventListener('DOMContentLoaded', function () {
                if (!checkHighlightJS()) {
                    console.warn('⚠️ highlight.js may not be loaded. Code highlighting may not work.');
                    console.warn('Please check your network connection and CDN availability.');
                }
            });
        }

        // Configure marked.js for GFM (GitHub Flavored Markdown) support including tables
        if (typeof marked !== 'undefined') {
            marked.setOptions({
                gfm: true,           // Enable GitHub Flavored Markdown
                breaks: false,       // Don't convert line breaks to <br>
                pedantic: false,     // Don't be pedantic
                sanitize: false,     // Don't sanitize HTML
                smartLists: true,    // Use smart list behavior
                smartypants: false,  // Don't use smart typography
                tables: true,        // Enable tables (part of GFM)
                headerIds: true,     // Add IDs to headers
                mangle: false,       // Don't mangle email addresses
                headerPrefix: ''     // No prefix for header IDs (for better anchor matching)
            });

            // Add custom extension to handle CJK bold parsing (e.g. **text** adjacent to punctuation)
            // Fixes: 中文**“...**
            marked.use({
                extensions: [{
                    name: 'strong-cjk',
                    level: 'inline',
                    start(src) { return src.match(/\*\*/)?.index; },
                    tokenizer(src, tokens) {
                        const rule = /^\*\*([^\s*](?:[^*]|\*(?!\*))*?[^\s*])\*\*(?!\*)/;
                        const rule1Char = /^\*\*([^\s*])\*\*(?!\*)/;
                        const match = rule1Char.exec(src) || rule.exec(src);
                        if (match) {
                            return {
                                type: 'strong-cjk',
                                raw: match[0],
                                text: match[1],
                                tokens: this.lexer.inlineTokens(match[1])
                            };
                        }
                    },
                    renderer(token) {
                        return `<strong>${this.parser.parseInline(token.tokens)}</strong>`;
                    }
                }]
            });
        }

        // Markdown Syntax Checker
        function checkMarkdownSyntax(markdownText) {
            const errors = [];
            const lines = markdownText.split('\n');
            let inCodeBlock = false;
            let codeBlockStartLine = 0;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const lineNum = i + 1;
                const trimmedLine = line.trim();

                // Check for code block markers
                if (trimmedLine.startsWith('```')) {
                    // Check for leading spaces before ```
                    if (line.match(/^\s+```/)) {
                        const leadingSpaces = line.match(/^(\s+)/)[1];
                        errors.push({
                            line: lineNum,
                            type: 'code-block-space',
                            message: `代码块标记前有 ${leadingSpaces.length} 个空格，可能导致代码块无法正确显示。代码块标记应该从行首开始。`,
                            fix: line.replace(/^\s+/, '')
                        });
                    }

                    // Check for trailing spaces after ```
                    if (line.match(/```\s+$/)) {
                        errors.push({
                            line: lineNum,
                            type: 'code-block-trailing-space',
                            message: '代码块标记后有空格，建议移除',
                            fix: line.trimEnd()
                        });
                    }

                    // Track code block state
                    if (!inCodeBlock) {
                        inCodeBlock = true;
                        codeBlockStartLine = lineNum;
                    } else {
                        inCodeBlock = false;
                    }
                }

                // Check for table formatting issues
                if (!inCodeBlock && line.includes('|')) {
                    // Check if it's a table separator row
                    const isSeparator = line.match(/^\s*\|[\s\-:]+\|\s*$/);

                    if (!isSeparator) {
                        // It's a table data row
                        const pipeCount = (line.match(/\|/g) || []).length;
                        if (pipeCount > 0 && pipeCount < 2) {
                            errors.push({
                                line: lineNum,
                                type: 'table-format',
                                message: `表格行可能格式不正确（只有 ${pipeCount} 个 | 符号，至少需要 2 个）`,
                                fix: null
                            });
                        }
                    }
                }
            }

            // Check for unclosed code blocks
            if (inCodeBlock) {
                const codeBlockType = lines[codeBlockStartLine - 1].match(/```(\w+)?/);
                const language = codeBlockType ? codeBlockType[1] : '';
                errors.push({
                    line: codeBlockStartLine,
                    type: 'unclosed-code-block',
                    message: `第 ${codeBlockStartLine} 行开始的代码块${language ? `（语言：${language}）` : ''}未闭合，请添加结束标记 \`\`\`。这可能导致后续内容被错误解析。`,
                    fix: null
                });
            }

            // Check for unmatched code blocks globally (double check)
            const allCodeBlocks = markdownText.match(/```/g);
            if (allCodeBlocks && allCodeBlocks.length % 2 !== 0) {
                errors.push({
                    line: lines.length,
                    type: 'unmatched-code-blocks',
                    message: `检测到 ${allCodeBlocks.length} 个代码块标记，数量为奇数，可能有未闭合的代码块`,
                    fix: null
                });
            }

            return errors;
        }

        // Store errors for tooltip display
        let syntaxErrorsMap = {};

        // Debounce timer for syntax check
        let syntaxCheckTimer = null;

        // Immediate syntax check function (called on every input)
        function checkSyntaxImmediately() {
            const input = document.getElementById('markdown-input');
            const markdownText = input.value;
            const syntaxErrors = checkMarkdownSyntax(markdownText);
            displaySyntaxErrors(syntaxErrors);
        }

        function displaySyntaxErrors(errors) {
            // Clear previous errors
            syntaxErrorsMap = {};

            if (errors.length === 0) {
                updateLineNumbers([]);
                return;
            }

            // Group errors by line number
            errors.forEach(error => {
                if (!syntaxErrorsMap[error.line]) {
                    syntaxErrorsMap[error.line] = [];
                }
                syntaxErrorsMap[error.line].push(error);
            });

            // Update line numbers with error highlighting
            const errorLines = errors.map(e => e.line);
            updateLineNumbers(errorLines);
        }

        // Update line numbers display - Optimized for performance
        function updateLineNumbers(errorLines = []) {
            requestAnimationFrame(() => {
                const input = document.getElementById('markdown-input');
                if (!input) return;
                const lineNumbersContainer = document.getElementById('line-numbers');
                const lines = input.value.split('\n');
                const totalLines = lines.length;


                // Get existing line number elements
                const existingElements = lineNumbersContainer.children;
                const existingCount = existingElements.length;

                // 1. Add new elements if needed
                if (totalLines > existingCount) {
                    const fragment = document.createDocumentFragment();
                    for (let i = existingCount + 1; i <= totalLines; i++) {
                        const lineNumber = document.createElement('span');
                        lineNumber.className = 'line-number';
                        lineNumber.textContent = i;
                        fragment.appendChild(lineNumber);
                    }
                    lineNumbersContainer.appendChild(fragment);
                }

                // 2. Remove excess elements if needed
                else if (totalLines < existingCount) {
                    for (let i = existingCount - 1; i >= totalLines; i--) {
                        lineNumbersContainer.removeChild(existingElements[i]);
                    }
                }

                // 3. Update error states
                // We only need to touch elements that have errors or had errors
                // First, clear all error states (this is fast if we track them, but for now we'll just loop)
                // Optimization: only loop if we have errors or had errors previously
                // For simplicity and correctness, we'll loop through all, but only touch DOM if class changes

                const errorSet = new Set(errorLines);

                for (let i = 0; i < totalLines; i++) {
                    const el = existingElements[i];
                    const lineNum = i + 1;
                    const hasError = errorSet.has(lineNum);
                    const isErrorClass = el.classList.contains('line-error');

                    if (hasError !== isErrorClass) {
                        if (hasError) {
                            el.classList.add('line-error');

                            // Add tooltip
                            let tooltip = el.querySelector('.line-number-error-tooltip');
                            if (!tooltip) {
                                tooltip = document.createElement('div');
                                tooltip.className = 'line-number-error-tooltip';
                                el.appendChild(tooltip);

                                // Add listeners only once
                                el.addEventListener('mouseenter', function () {
                                    updateTooltipPosition(tooltip, el);
                                });
                                el.addEventListener('click', function () {
                                    updateTooltipPosition(tooltip, el);
                                });
                            }

                            // Update tooltip text
                            const errors = syntaxErrorsMap[lineNum] || [];
                            const errorMessages = errors.map(e => {
                                let msg = `行 ${i}: ${e.message}`;
                                if (e.fix) {
                                    msg += `\n修复: ${e.fix}`;
                                }
                                return msg;
                            }).join('\n\n');
                            tooltip.textContent = errorMessages;

                        } else {
                            el.classList.remove('line-error');
                            // We keep the tooltip element but it won't be shown due to CSS
                            // or we could remove it to save memory
                            const tooltip = el.querySelector('.line-number-error-tooltip');
                            if (tooltip) {
                                el.removeChild(tooltip);
                            }
                        }
                    }
                }
            });
        }

        // Update tooltip position
        function updateTooltipPosition(tooltip, lineNumber) {
            const rect = lineNumber.getBoundingClientRect();
            const tooltipRect = tooltip.getBoundingClientRect();

            // Position tooltip to the right of line number
            let left = rect.right + 8;
            let top = rect.top + (rect.height / 2) - (tooltipRect.height / 2);

            // Adjust if tooltip goes off screen
            if (left + tooltipRect.width > window.innerWidth) {
                left = rect.left - tooltipRect.width - 8;
            }
            if (top + tooltipRect.height > window.innerHeight) {
                top = window.innerHeight - tooltipRect.height - 8;
            }
            if (top < 0) {
                top = 8;
            }

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';

            // Sync scroll
            syncLineNumbersScroll();
        }

        // Sync line numbers scroll with textarea
        function syncLineNumbersScroll() {
            const input = document.getElementById('markdown-input');
            const lineNumbersContainer = document.getElementById('line-numbers');

            lineNumbersContainer.scrollTop = input.scrollTop;
        }

        /**
         * Sync scroll functions are now in main.js (md2pdfSyncScroll object)
         * These wrapper functions provide backward compatibility and error handling
         */

        /**
         * Get md2pdfSyncScroll object from main.js
         * Tries both direct reference and window reference for compatibility
         */
        function getSyncScroll() {
            if (typeof md2pdfSyncScroll !== 'undefined') {
                return md2pdfSyncScroll;
            }
            if (typeof window !== 'undefined' && window.md2pdfSyncScroll) {
                return window.md2pdfSyncScroll;
            }
            return null;
        }

        /**
         * Toggle sync scroll feature
         * Wrapper function that calls md2pdfSyncScroll.toggle() from main.js
         */
        function toggleSyncScroll() {
            const syncScroll = getSyncScroll();
            if (syncScroll && typeof syncScroll.toggle === 'function') {
                syncScroll.toggle();
            } else {
                console.warn('md2pdfSyncScroll is not available. Please ensure main.js is loaded.');
            }
        }

        /**
         * Sync preview scroll with editor scroll (Editor -> Preview)
         * Wrapper function that calls md2pdfSyncScroll.sync() from main.js
         * This function is called when the editor textarea is scrolled
         */
        function syncPreviewScroll() {
            const syncScroll = getSyncScroll();
            if (syncScroll && typeof syncScroll.sync === 'function') {
                syncScroll.sync();
            }
            // Silently fail if main.js is not loaded yet
            // This prevents errors during page load
        }


        // Debounce timer for preview update
        let previewUpdateTimer = null;

        function updatePreview(includeSyntaxCheck = false, skipHashScroll = false) {
            const input = document.getElementById('markdown-input');
            const output = document.getElementById('preview-output');
            const enableMermaid = document.getElementById('enable-mermaid').checked;
            const enableLatex = document.getElementById('enable-latex').checked;

            let markdownText = input.value;

            // Check syntax if explicitly requested (for non-input events like Mermaid/LaTeX toggle)
            if (includeSyntaxCheck) {
                const syntaxErrors = checkMarkdownSyntax(markdownText);
                displaySyntaxErrors(syntaxErrors);
            }

            // Check if marked is loaded
            if (typeof marked === 'undefined') {
                output.innerHTML = '<div style="color: red; padding: 20px;">Error: Markdown library (marked.js) failed to load. Please check your internet connection or try refreshing the page.</div>';
                return;
            }

            try {
                // Configure marked renderer to ensure consistent ID generation
                // Support Chinese, emoji, and other UTF-8 characters
                const renderer = new marked.Renderer();
                const originalHeading = renderer.heading.bind(renderer);

                // Custom slug function that preserves UTF-8 characters (Chinese, emoji, etc.)
                function createSlug(text) {
                    if (!text) return '';

                    // Convert to string and trim
                    let slug = String(text).trim();

                    // Replace spaces and underscores with hyphens
                    slug = slug.replace(/[\s_]+/g, '-');

                    // Remove leading/trailing hyphens
                    slug = slug.replace(/^-+|-+$/g, '');

                    // Keep UTF-8 characters (Chinese, emoji, etc.) but normalize multiple hyphens
                    slug = slug.replace(/-+/g, '-');

                    // If slug is empty after processing, generate a fallback
                    if (!slug) {
                        slug = 'heading-' + Math.random().toString(36).substr(2, 9);
                    }

                    return slug;
                }

                renderer.heading = function (text, level, raw, slugger) {
                    // Use custom slug function that preserves UTF-8 characters
                    const id = createSlug(raw);
                    // Ensure ID is URL-safe by encoding if needed, but keep it readable
                    const safeId = id; // Keep original for better matching
                    return `<h${level} id="${safeId}">${text}</h${level}>`;
                };

                marked.setOptions({
                    renderer: renderer
                });

                const html = marked.parse(markdownText);
                // Clear previous content and set new HTML
                // This ensures code highlighting is reapplied on every update
                output.innerHTML = html;

                // Post-process images to ensure data URIs are properly handled
                // Some markdown parsers may escape or modify data URIs
                output.querySelectorAll('img').forEach((img) => {
                    const src = img.getAttribute('src');
                    if (src && src.startsWith('data:image')) {
                        // Ensure data URI is properly set
                        img.src = src;
                        // Add error handling for images
                        img.onerror = function () {
                            console.warn('Image failed to load:', src.substring(0, 50) + '...');
                        };
                    }
                });

                // Handle anchor links - scroll to target when clicked
                // Support both #hash and full URL formats like /index.html#hash
                output.querySelectorAll('a[href*="#"]').forEach((link) => {
                    link.addEventListener('click', function (e) {
                        const href = this.getAttribute('href');
                        if (href && href.includes('#')) {
                            // Extract hash from href (supports both #hash and /path#hash formats)
                            let hash = href;
                            const hashIndex = href.indexOf('#');
                            if (hashIndex !== -1) {
                                hash = href.substring(hashIndex);
                            }

                            if (hash.startsWith('#')) {
                                const targetId = decodeURIComponent(hash.substring(1));

                                // Function to find target element by various methods
                                // Supports Chinese, emoji, and other UTF-8 characters
                                function findTargetElement(id) {
                                    if (!id) return null;

                                    // Clean the ID (remove leading/trailing dashes, handle special cases)
                                    const cleanId = id.replace(/^-+|-+$/g, '');

                                    // Helper function to safely query selector with UTF-8 characters
                                    function safeQuerySelector(selector) {
                                        try {
                                            // Try with CSS.escape
                                            return output.querySelector(`#${CSS.escape(selector)}`);
                                        } catch (e) {
                                            // If CSS.escape fails, try direct query
                                            try {
                                                return output.querySelector(`#${selector}`);
                                            } catch (e2) {
                                                // If that also fails, try attribute selector
                                                return output.querySelector(`[id="${selector}"]`);
                                            }
                                        }
                                    }

                                    // Try direct ID match (exact)
                                    let targetElement = safeQuerySelector(id);
                                    if (targetElement) return targetElement;

                                    // Try cleaned ID
                                    targetElement = safeQuerySelector(cleanId);
                                    if (targetElement) return targetElement;

                                    // Try URL-encoded version
                                    try {
                                        targetElement = safeQuerySelector(encodeURIComponent(id));
                                        if (targetElement) return targetElement;
                                    } catch (e) {
                                        // Ignore
                                    }

                                    // Try URL-decoded version
                                    try {
                                        const decodedId = decodeURIComponent(id);
                                        targetElement = safeQuerySelector(decodedId);
                                        if (targetElement) return targetElement;
                                    } catch (e) {
                                        // Ignore decode errors
                                    }

                                    // Try with normalized ID format (preserve UTF-8 characters)
                                    // Keep Chinese, emoji, and other Unicode characters
                                    const normalizedId = id.trim()
                                        .replace(/\s+/g, '-')
                                        .replace(/-+/g, '-')
                                        .replace(/^-+|-+$/g, '');
                                    targetElement = safeQuerySelector(normalizedId);
                                    if (targetElement) return targetElement;

                                    // Try lowercase version (but preserve UTF-8 characters)
                                    const lowerId = id.toLowerCase();
                                    if (lowerId !== id) {
                                        targetElement = safeQuerySelector(lowerId);
                                        if (targetElement) return targetElement;
                                    }

                                    // Try all possible variations
                                    const variations = [
                                        id,
                                        cleanId,
                                        normalizedId,
                                        id.replace(/_/g, '-'),
                                        id.replace(/-/g, '_'),
                                        id.replace(/\s+/g, '-'),
                                        id.replace(/\s+/g, '_')
                                    ];

                                    // Add encoded/decoded variations
                                    try {
                                        variations.push(encodeURIComponent(id));
                                        variations.push(decodeURIComponent(id));
                                    } catch (e) {
                                        // Ignore
                                    }

                                    for (const variant of variations) {
                                        if (variant && variant !== id) {
                                            targetElement = safeQuerySelector(variant);
                                            if (targetElement) return targetElement;
                                        }
                                    }

                                    // Try finding by text content (fallback) - supports UTF-8
                                    const allHeaders = output.querySelectorAll('h1, h2, h3, h4, h5, h6');
                                    for (let header of allHeaders) {
                                        const headerId = header.id || '';
                                        const headerText = header.textContent.trim();

                                        // Match by ID (exact or normalized) - UTF-8 aware
                                        if (headerId === id ||
                                            headerId === cleanId ||
                                            headerId === normalizedId ||
                                            headerId === encodeURIComponent(id) ||
                                            headerId === decodeURIComponent(id)) {
                                            return header;
                                        }

                                        // Match by text content - preserve UTF-8 characters
                                        // Normalize: spaces to hyphens, but keep all UTF-8 characters
                                        const normalizedText = headerText
                                            .trim()
                                            .replace(/\s+/g, '-')
                                            .replace(/-+/g, '-')
                                            .replace(/^-+|-+$/g, '');

                                        const normalizedIdFromText = id.trim()
                                            .replace(/\s+/g, '-')
                                            .replace(/-+/g, '-')
                                            .replace(/^-+|-+$/g, '');

                                        if (normalizedText === normalizedIdFromText ||
                                            headerText === id ||
                                            headerText === cleanId ||
                                            headerText.toLowerCase() === id.toLowerCase()) {
                                            return header;
                                        }

                                        // Also try matching raw text directly
                                        if (headerText === id || headerText.includes(id) || id.includes(headerText)) {
                                            return header;
                                        }
                                    }

                                    return null;
                                }

                                const targetElement = findTargetElement(targetId);

                                if (targetElement) {
                                    e.preventDefault();

                                    // Scroll to target within preview output (which is the scrollable container)
                                    // #preview-output has overflow-y: auto, so it's the scroll container
                                    const scrollContainer = output; // output is #preview-output

                                    if (scrollContainer) {
                                        // Calculate scroll position relative to the scroll container
                                        const containerRect = scrollContainer.getBoundingClientRect();
                                        const targetRect = targetElement.getBoundingClientRect();

                                        // Get current scroll position
                                        const currentScrollTop = scrollContainer.scrollTop;

                                        // Calculate target scroll position
                                        // targetRect.top is relative to viewport
                                        // containerRect.top is also relative to viewport
                                        // So targetRect.top - containerRect.top gives position relative to container
                                        // Add current scroll position to get absolute scroll position
                                        const targetScrollTop = currentScrollTop + (targetRect.top - containerRect.top) - 20; // 20px offset from top

                                        // Scroll to target
                                        scrollContainer.scrollTo({
                                            top: Math.max(0, targetScrollTop),
                                            behavior: 'smooth'
                                        });
                                    } else {
                                        // Fallback: use scrollIntoView
                                        targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                    }

                                    // Update URL hash without triggering scroll
                                    if (history.pushState) {
                                        history.pushState(null, null, hash);
                                    }
                                }
                            }
                        }
                    });
                });

                // Handle initial hash in URL - scroll to target on load
                function scrollToHash() {
                    if (window.location.hash) {
                        const hash = decodeURIComponent(window.location.hash.substring(1));

                        // Function to find target element by various methods
                        // Supports Chinese, emoji, and other UTF-8 characters
                        function findTargetElement(id) {
                            if (!id) return null;

                            // Clean the ID (remove leading/trailing dashes, handle special cases)
                            const cleanId = id.replace(/^-+|-+$/g, '');

                            // Helper function to safely query selector with UTF-8 characters
                            function safeQuerySelector(selector) {
                                try {
                                    // Try with CSS.escape
                                    return output.querySelector(`#${CSS.escape(selector)}`);
                                } catch (e) {
                                    // If CSS.escape fails, try direct query
                                    try {
                                        return output.querySelector(`#${selector}`);
                                    } catch (e2) {
                                        // If that also fails, try attribute selector
                                        return output.querySelector(`[id="${selector}"]`);
                                    }
                                }
                            }

                            // Try direct ID match (exact)
                            let targetElement = safeQuerySelector(id);
                            if (targetElement) return targetElement;

                            // Try cleaned ID
                            targetElement = safeQuerySelector(cleanId);
                            if (targetElement) return targetElement;

                            // Try URL-encoded version
                            try {
                                targetElement = safeQuerySelector(encodeURIComponent(id));
                                if (targetElement) return targetElement;
                            } catch (e) {
                                // Ignore
                            }

                            // Try URL-decoded version
                            try {
                                const decodedId = decodeURIComponent(id);
                                targetElement = safeQuerySelector(decodedId);
                                if (targetElement) return targetElement;
                            } catch (e) {
                                // Ignore decode errors
                            }

                            // Try with normalized ID format (preserve UTF-8 characters)
                            const normalizedId = id.trim()
                                .replace(/\s+/g, '-')
                                .replace(/-+/g, '-')
                                .replace(/^-+|-+$/g, '');
                            targetElement = safeQuerySelector(normalizedId);
                            if (targetElement) return targetElement;

                            // Try lowercase version (but preserve UTF-8 characters)
                            const lowerId = id.toLowerCase();
                            if (lowerId !== id) {
                                targetElement = safeQuerySelector(lowerId);
                                if (targetElement) return targetElement;
                            }

                            // Try all possible variations
                            const variations = [
                                id,
                                cleanId,
                                normalizedId,
                                id.replace(/_/g, '-'),
                                id.replace(/-/g, '_'),
                                id.replace(/\s+/g, '-'),
                                id.replace(/\s+/g, '_')
                            ];

                            // Add encoded/decoded variations
                            try {
                                variations.push(encodeURIComponent(id));
                                variations.push(decodeURIComponent(id));
                            } catch (e) {
                                // Ignore
                            }

                            for (const variant of variations) {
                                if (variant && variant !== id) {
                                    targetElement = safeQuerySelector(variant);
                                    if (targetElement) return targetElement;
                                }
                            }

                            // Try finding by text content (fallback) - supports UTF-8
                            const allHeaders = output.querySelectorAll('h1, h2, h3, h4, h5, h6');
                            for (let header of allHeaders) {
                                const headerId = header.id || '';
                                const headerText = header.textContent.trim();

                                // Match by ID (exact or normalized) - UTF-8 aware
                                if (headerId === id ||
                                    headerId === cleanId ||
                                    headerId === normalizedId ||
                                    headerId === encodeURIComponent(id) ||
                                    headerId === decodeURIComponent(id)) {
                                    return header;
                                }

                                // Match by text content - preserve UTF-8 characters
                                const normalizedText = headerText
                                    .trim()
                                    .replace(/\s+/g, '-')
                                    .replace(/-+/g, '-')
                                    .replace(/^-+|-+$/g, '');

                                const normalizedIdFromText = id.trim()
                                    .replace(/\s+/g, '-')
                                    .replace(/-+/g, '-')
                                    .replace(/^-+|-+$/g, '');

                                if (normalizedText === normalizedIdFromText ||
                                    headerText === id ||
                                    headerText === cleanId ||
                                    headerText.toLowerCase() === id.toLowerCase()) {
                                    return header;
                                }

                                // Also try matching raw text directly
                                if (headerText === id || headerText.includes(id) || id.includes(headerText)) {
                                    return header;
                                }
                            }

                            return null;
                        }

                        const targetElement = findTargetElement(hash);

                        if (targetElement) {
                            // Scroll to target within preview output (which is the scrollable container)
                            const scrollContainer = output; // output is #preview-output

                            if (scrollContainer) {
                                // Calculate scroll position relative to the scroll container
                                const containerRect = scrollContainer.getBoundingClientRect();
                                const targetRect = targetElement.getBoundingClientRect();

                                // Get current scroll position
                                const currentScrollTop = scrollContainer.scrollTop;

                                // Calculate target scroll position
                                const targetScrollTop = currentScrollTop + (targetRect.top - containerRect.top) - 20; // 20px offset from top

                                // Scroll to target
                                scrollContainer.scrollTo({
                                    top: Math.max(0, targetScrollTop),
                                    behavior: 'smooth'
                                });
                            } else {
                                // Fallback: use scrollIntoView
                                targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            }
                        }
                    }
                }

                // Scroll to hash after rendering completes (only if not skipped)
                if (!skipHashScroll) {
                    setTimeout(scrollToHash, 500);
                }
            } catch (e) {
                console.error('Markdown parsing error:', e);
                output.innerHTML = '<div style="color: red;">Error parsing Markdown</div>';
                return;
            }

            // Process mermaid blocks first, before highlighting
            if (enableMermaid && window.mermaid && mermaidInitialized) {
                // Find all code blocks that might be mermaid
                output.querySelectorAll('pre code').forEach((el) => {
                    const codeText = el.textContent.trim();
                    const className = el.className || '';

                    // Check if it's a mermaid code block - only by className to avoid false positives
                    // marked.js will add 'language-mermaid' class for ```mermaid code blocks
                    const isMermaid = className.includes('language-mermaid');

                    // Also check if code starts with mermaid diagram keywords (fallback for unmarked blocks)
                    const looksLikeMermaid = !isMermaid && codeText.match(/^\s*(graph|gantt|sequenceDiagram|pie|stateDiagram|classDiagram|erDiagram|journey|gitGraph|flowchart)/);

                    if (isMermaid || looksLikeMermaid) {
                        // Extract mermaid code - use the code text as-is
                        let graphDefinition = codeText;

                        // Only remove 'mermaid' prefix if it's clearly a language identifier at the start
                        // This handles cases where marked.js might include 'mermaid' in the code text
                        if (isMermaid && graphDefinition.startsWith('mermaid\n')) {
                            graphDefinition = graphDefinition.replace(/^mermaid\n/, '');
                        } else if (isMermaid && graphDefinition.startsWith('mermaid ')) {
                            graphDefinition = graphDefinition.replace(/^mermaid /, '');
                        }

                        // Clean up the graph definition - remove any trailing markdown syntax that might have leaked in
                        // Remove any lines that look like markdown headers or code block markers
                        const lines = graphDefinition.split('\n');
                        const cleanedLines = [];
                        for (let i = 0; i < lines.length; i++) {
                            const line = lines[i];
                            // Stop if we encounter markdown syntax that shouldn't be in mermaid code
                            if (line.match(/^#{1,6}\s/) || line.trim() === '```' || line.trim().startsWith('```')) {
                                break;
                            }
                            cleanedLines.push(line);
                        }
                        graphDefinition = cleanedLines.join('\n').trim();

                        // Create a div for mermaid to render into
                        const mermaidDiv = document.createElement('div');
                        mermaidDiv.className = 'mermaid';
                        mermaidDiv.textContent = graphDefinition;

                        // Store original code for error display
                        mermaidDiv.setAttribute('data-original-code', codeText);

                        // Replace the pre element with the new div
                        const preElement = el.parentElement;
                        if (preElement && preElement.tagName === 'PRE') {
                            preElement.replaceWith(mermaidDiv);
                        }
                    }
                });

                // Render all mermaid diagrams after a short delay to ensure DOM is ready
                setTimeout(() => {
                    try {
                        const mermaidElements = output.querySelectorAll('.mermaid');
                        if (mermaidElements.length > 0) {
                            mermaid.run({
                                nodes: mermaidElements
                            }).catch(err => {
                                console.error('Mermaid rendering error:', err);
                                // Display error message in the mermaid element
                                mermaidElements.forEach((el, index) => {
                                    // Check if this element failed to render
                                    if (!el.querySelector('svg')) {
                                        const errorDiv = document.createElement('div');
                                        errorDiv.style.cssText = 'padding: 15px; background: #fee; border: 2px solid #fcc; border-radius: 4px; color: #c33; font-family: monospace; white-space: pre-wrap;';
                                        errorDiv.innerHTML = '<strong>❌ Mermaid 图表渲染错误</strong><br><br>' +
                                            '<strong>错误信息：</strong><br>' +
                                            (err.message || err.str || JSON.stringify(err)) +
                                            '<br><br><strong>代码内容：</strong><br>' +
                                            '<code style="background: #f5f5f5; padding: 5px; display: block; margin-top: 5px;">' +
                                            (el.getAttribute('data-original-code') || el.textContent || '').substring(0, 500) +
                                            '</code>';
                                        el.parentNode.replaceChild(errorDiv, el);
                                    }
                                });
                            });
                        }
                    } catch (e) {
                        console.error('Mermaid rendering error:', e);
                        // Display error for all mermaid elements if there's a general error
                        const mermaidElements = output.querySelectorAll('.mermaid');
                        mermaidElements.forEach((el) => {
                            if (!el.querySelector('svg')) {
                                const errorDiv = document.createElement('div');
                                errorDiv.style.cssText = 'padding: 15px; background: #fee; border: 2px solid #fcc; border-radius: 4px; color: #c33; font-family: monospace;';
                                errorDiv.innerHTML = '<strong>❌ Mermaid 图表渲染错误</strong><br><br>' +
                                    '<strong>错误信息：</strong><br>' +
                                    (e.message || String(e)) +
                                    '<br><br><strong>请检查代码块是否正确闭合（确保有结束的 ```）</strong>';
                                el.parentNode.replaceChild(errorDiv, el);
                            }
                        });
                    }
                }, 100);
            }

            // Apply syntax highlighting for non-mermaid code blocks
            // Always reapply highlighting on every update to ensure it's current
            if (window.hljs) {
                // Use setTimeout to ensure DOM is ready after marked.parse
                setTimeout(() => {
                    const codeBlocks = output.querySelectorAll('pre code');
                    console.log('Found code blocks:', codeBlocks.length); // Debug log

                    codeBlocks.forEach((el) => {
                        // Skip if already processed as mermaid
                        if (!el.closest('.mermaid')) {
                            try {
                                // Remove any existing hljs classes to force re-highlighting
                                // This ensures highlighting is reapplied on every content change
                                el.classList.remove('hljs');
                                // Remove all highlight.js syntax classes
                                Array.from(el.classList).forEach(cls => {
                                    if (cls.startsWith('hljs-')) {
                                        el.classList.remove(cls);
                                    }
                                });

                                // Get the language from class or detect it
                                let language = null;
                                const classList = Array.from(el.classList);
                                for (const cls of classList) {
                                    if (cls.startsWith('language-')) {
                                        language = cls.replace('language-', '');
                                        break;
                                    }
                                }

                                // Re-highlight the element - this will add hljs class and syntax classes
                                if (language) {
                                    hljs.highlightElement(el);
                                } else {
                                    // Try to auto-detect language
                                    hljs.highlightElement(el);
                                }



                                console.log('Highlighted element:', el.className); // Debug log
                            } catch (e) {
                                console.error('Highlight error:', e, el);
                            }
                        }
                    });
                }, 100); // Increased delay to ensure DOM is ready
            } else {
                console.warn('highlight.js not loaded');
            }

            if (enableLatex) {
                // Only try to render MathJax if it's ready
                // Don't block or retry on initial page load
                if (!window.MathJax || !window.MathJax.typesetPromise) {
                    console.log('MathJax not ready yet, skipping LaTeX rendering');
                    return;
                }

                // Prevent multiple simultaneous rendering calls
                if (window._mathJaxRendering) {
                    return;
                }

                // Mark as rendering
                window._mathJaxRendering = true;

                // Use typesetPromise for MathJax 3.x
                try {
                    MathJax.typesetPromise([output]).then(() => {
                        console.log('MathJax rendering completed');
                        window._mathJaxRendering = false;
                    }).catch((err) => {
                        console.error('MathJax typeset error:', err);
                        window._mathJaxRendering = false;
                    });
                } catch (err) {
                    console.error('MathJax rendering error:', err);
                    window._mathJaxRendering = false;
                }
            }
        }

        // Helper function to get current style name
        function getCurrentStyle() {
            const workspace = document.getElementById('workspace');
            if (workspace.className.includes('style-modern')) return 'modern';
            if (workspace.className.includes('style-hacker')) return 'hacker';
            if (workspace.className.includes('style-minimal')) return 'minimal';
            if (workspace.className.includes('style-dark')) return 'dark';
            if (workspace.className.includes('style-colorful')) return 'colorful';
            if (workspace.className.includes('style-professional')) return 'professional';
            return 'default';
        }

        function changeStyle() {
            const style = document.getElementById('style-selector').value;
            const currentFont = getCurrentFont();
            // Preserve font class when changing style
            workspace.className = 'workspace ' + style + (currentFont ? ' ' + currentFont : '');
            // Update preview to reflect style changes
            updatePreview();
        }

        function changeFont() {
            const fontSelector = document.getElementById('font-selector').value;
            // Map font-family values to CSS class names
            const fontMap = {
                "'Microsoft YaHei', '微软雅黑', sans-serif": 'font-yahei',
                "'SimSun', '宋体', serif": 'font-simsun',
                "'KaiTi', '楷体', serif": 'font-kaiti',
                "'SimHei', '黑体', sans-serif": 'font-simhei',
                "'FangSong', '仿宋', serif": 'font-fangsong',
                "'PingFang SC', '苹方', sans-serif": 'font-pingfang',
                "'Noto Sans SC', '思源黑体', sans-serif": 'font-noto',
                "'Noto Serif SC', '思源宋体', serif": 'font-noto-serif',
                "'WenQuanYi Micro Hei', '文泉驿微米黑', sans-serif": 'font-wenquanyi',
                "'STHeiti', '华文黑体', sans-serif": 'font-stheiti',
                "'STSong', '华文宋体', serif": 'font-stsong',
                "'STKaiti', '华文楷体', serif": 'font-stkaiti',
                "'Arial', sans-serif": 'font-arial',
                "'Times New Roman', serif": 'font-times',
                "'Courier New', monospace": 'font-courier',
                "'Georgia', serif": 'font-georgia',
                "'Verdana', sans-serif": 'font-verdana'
            };

            const fontClass = fontMap[fontSelector];
            if (fontClass) {
                // Remove all existing font classes
                const allFontClasses = Object.values(fontMap);
                workspace.classList.remove(...allFontClasses);
                // Add the new font class
                workspace.classList.add(fontClass);
            }
        }

        // Helper function to get current font class
        function getCurrentFont() {
            const fontClasses = [
                'font-yahei', 'font-simsun', 'font-kaiti', 'font-simhei',
                'font-fangsong', 'font-pingfang', 'font-noto', 'font-noto-serif',
                'font-wenquanyi', 'font-stheiti', 'font-stsong', 'font-stkaiti',
                'font-arial', 'font-times', 'font-courier', 'font-georgia', 'font-verdana'
            ];
            for (const fontClass of fontClasses) {
                if (workspace.classList.contains(fontClass)) {
                    return fontClass;
                }
            }
            return '';
        }

        function changeBgColor() {
            const enabled = document.getElementById('enable-bg-color').checked;
            const color = document.getElementById('bg-color').value;
            const colorPicker = document.getElementById('bg-color');

            // Update picker state
            colorPicker.disabled = !enabled;
            colorPicker.style.opacity = enabled ? '1' : '0.5';

            if (enabled) {
                output.style.backgroundColor = color;
            } else {
                output.style.backgroundColor = ''; // Clear inline style to strictly follow theme
            }
        }

        // Update Watermark using Library
        function updateWatermark() {
            const enabled = document.getElementById('enable-watermark').checked;
            const controls = document.getElementById('watermark-controls');
            const text = document.getElementById('watermark-text').value;
            const type = document.getElementById('watermark-type').value;

            // Toggle controls
            controls.style.display = enabled ? 'flex' : 'none';

            // Remove existing watermark (library usually appends to body or specific container with fixed pos)
            // watermark-dom usually manages its own instance, but we might need to clear it.
            // If the library attaches to body, we might need a way to remove it.
            // Assuming watermark-dom exposes a global 'watermark'.

            // Standard cleanup if possible, or just overwrite.
            const existingNodes = document.querySelectorAll('.watermark_div'); // Specific to typical libs
            existingNodes.forEach(node => node.remove());

            // Also remove our custom one if it exists
            const custom = document.getElementById('watermark');
            if (custom) custom.remove();

            if (enabled && text && typeof watermark !== 'undefined') {
                if (type === 'full') {
                    watermark.load({
                        watermark_txt: text,
                        watermark_x: 20,
                        watermark_y: 20,
                        watermark_rows: 0, // auto
                        watermark_cols: 0, // auto
                        watermark_x_space: 100,
                        watermark_y_space: 50,
                        watermark_color: 'rgba(128, 128, 128, 0.15)',
                        watermark_fontsize: '24px',
                        watermark_angle: 45
                    });
                } else {
                    // Footer only - Custom implementation is better for single footer, 
                    // but user asked for Library.
                    // Libraries usually do full page tiling.
                    // We'll stick to our custom Footer code for "Footer" mode as libraries are bad at single placement,
                    // but use Library for "Full Page".

                    const output = document.getElementById('preview-output');
                    const wm = document.createElement('div');
                    wm.id = 'watermark';
                    wm.className = 'watermark-container watermark-footer';
                    wm.textContent = text;
                    output.appendChild(wm);
                }
            } else if (enabled && text) {
                // Fallback if library fails
                console.warn('Watermark library not loaded');
            }
        }
        // Toggle input area visibility


        function toggleInputVisibility() {
            const showInput = document.getElementById('show-input').checked;
            const editorContainer = document.querySelector('.editor-container');
            if (showInput) {
                editorContainer.classList.remove('hidden');
            } else {
                editorContainer.classList.add('hidden');
            }
            // Update workspace grid when one panel is hidden
            updateWorkspaceLayout();
        }

        // Toggle preview area visibility
        function togglePreviewVisibility() {
            const showPreview = document.getElementById('show-preview').checked;
            const previewContainer = document.querySelector('.preview-container');
            if (showPreview) {
                previewContainer.classList.remove('hidden');
            } else {
                previewContainer.classList.add('hidden');
            }
            // Update workspace grid when one panel is hidden
            updateWorkspaceLayout();
        }

        // Update workspace layout based on visibility
        function updateWorkspaceLayout() {
            const workspace = document.getElementById('workspace');
            const showInput = document.getElementById('show-input').checked;
            const showPreview = document.getElementById('show-preview').checked;

            // If both are visible, use two columns
            if (showInput && showPreview) {
                workspace.style.gridTemplateColumns = '1fr 1fr';
            } else if (showInput || showPreview) {
                // If only one is visible, use full width
                workspace.style.gridTemplateColumns = '1fr';
            }
        }

        // Track if ToC is already inserted
        let tocInserted = false;
        let originalContent = '';
        let tocUpdateTimer = null;
        let originalPageTitle = document.title; // Store original page title

        // Function to get the first actual heading from markdown content (skip ToC title)
        function getFirstActualHeadingFromMarkdown(markdown) {
            if (!markdown) return null;

            // Get current language and ToC title
            const currentLang = localStorage.getItem('lang') || 'zh';
            const tocTitle = (typeof translations !== 'undefined' && translations[currentLang] && translations[currentLang]['toc_title_in_doc'])
                ? translations[currentLang]['toc_title_in_doc']
                : (currentLang === 'zh' ? '生成目录' : 'Table of Contents');

            const lines = markdown.split('\n');
            let isCodeBlock = false;
            let foundTocTitle = false;

            for (let line of lines) {
                const trimmed = line.trim();

                // Track code blocks to skip them
                if (trimmed.startsWith('```')) {
                    isCodeBlock = !isCodeBlock;
                    continue;
                }

                if (isCodeBlock) {
                    continue;
                }

                // Check for ATX-style headers: ## My Header
                if (trimmed.startsWith('#')) {
                    const match = trimmed.match(/(#+)\s*(.*?)#*\s*$/);
                    if (match) {
                        const title = match[2].trim();
                        // Skip ToC title
                        if (title === tocTitle) {
                            foundTocTitle = true;
                            continue;
                        }
                        // If we found ToC title before, this is the first actual heading
                        // Or if no ToC title found, this is the first heading
                        if (title) {
                            return title;
                        }
                    }
                }
            }

            return null;
        }

        // Function to get the first actual heading from preview DOM (skip ToC title)
        function getFirstActualHeading() {
            const output = document.getElementById('preview-output');
            if (!output) return null;

            // Get current language and ToC title
            const currentLang = localStorage.getItem('lang') || 'zh';
            const tocTitle = (typeof translations !== 'undefined' && translations[currentLang] && translations[currentLang]['toc_title_in_doc'])
                ? translations[currentLang]['toc_title_in_doc']
                : (currentLang === 'zh' ? '生成目录' : 'Table of Contents');

            // Get all headers
            const allHeaders = output.querySelectorAll('h1, h2, h3, h4, h5, h6');

            // Find the first header that is NOT the ToC title
            for (let header of allHeaders) {
                const headerText = header.textContent.trim();
                if (headerText !== tocTitle) {
                    return header;
                }
            }

            // If no header found (except ToC), return the first one anyway
            return allHeaders.length > 0 ? allHeaders[0] : null;
        }

        // Function to scroll to top of preview
        function scrollToTocTitle() {
            const output = document.getElementById('preview-output');
            if (!output) return;

            // Wait for preview to update, then scroll to top (reduced delay for 2x speed)
            setTimeout(() => {
                const scrollContainer = output;
                if (scrollContainer) {
                    // Fast scroll animation to top (2x speed)
                    const startScrollTop = scrollContainer.scrollTop;
                    const targetScrollTop = 0;
                    const distance = targetScrollTop - startScrollTop;
                    const duration = 200; // Reduced from default ~400ms to 200ms for 2x speed
                    const startTime = performance.now();

                    function animateScroll(currentTime) {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        // Easing function for smooth but fast animation
                        const ease = progress < 0.5
                            ? 2 * progress * progress
                            : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                        scrollContainer.scrollTop = startScrollTop + distance * ease;

                        if (progress < 1) {
                            requestAnimationFrame(animateScroll);
                        }
                    }

                    requestAnimationFrame(animateScroll);
                }
            }, 300); // Reduced from 600ms to 300ms for 2x speed
        }

        // Function to get filename from first actual heading
        function getFilenameFromFirstHeading(extension) {
            const autoTitleEnabled = document.getElementById('export-auto-title')?.checked;

            if (autoTitleEnabled) {
                const firstHeading = getFirstActualHeading();
                if (firstHeading) {
                    let filename = firstHeading.textContent.trim();
                    // Remove invalid filename characters
                    filename = filename.replace(/[<>:"/\\|?*]/g, '');
                    // Replace spaces and special chars with hyphens
                    filename = filename.replace(/[\s_]+/g, '-');
                    // Remove leading/trailing hyphens
                    filename = filename.replace(/^-+|-+$/g, '');
                    // Limit length
                    if (filename.length > 50) {
                        filename = filename.substring(0, 50);
                    }
                    // If empty or too short, use default
                    if (!filename || filename.length < 1) {
                        filename = 'document';
                    }
                    return filename + extension;
                }
            }
            return 'document' + extension;
        }

        // Increase ToC level
        function increaseTocLevel() {
            const levelInput = document.getElementById('toc-levels');
            let currentLevel = parseInt(levelInput.value) || 3;
            if (currentLevel < 10) {
                levelInput.value = currentLevel + 1;
                // Immediately regenerate and insert ToC if checkbox is checked
                updateTocInDocument();
                // Scroll to ToC title after update
                scrollToTocTitle();
            }
        }

        // Decrease ToC level
        function decreaseTocLevel() {
            const levelInput = document.getElementById('toc-levels');
            let currentLevel = parseInt(levelInput.value) || 3;
            if (currentLevel > 1) {
                levelInput.value = currentLevel - 1;
                // Immediately regenerate and insert ToC if checkbox is checked
                updateTocInDocument();
                // Scroll to ToC title after update
                scrollToTocTitle();
            }
        }

        // Validate ToC level
        function validateTocLevel() {
            const levelInput = document.getElementById('toc-levels');
            let level = parseInt(levelInput.value) || 3;
            if (level < 1) level = 1;
            if (level > 10) level = 10;
            levelInput.value = level;
            // Immediately regenerate and insert ToC if checkbox is checked
            updateTocInDocument();
            // Scroll to ToC title after update
            scrollToTocTitle();
        }

        // Handle ToC insert checkbox change
        function handleTocInsertChange() {
            const shouldInsert = document.getElementById('toc-insert').checked;
            if (shouldInsert) {
                updateTocInDocument();
            } else {
                // Remove ToC if unchecked
                removeTocFromDocument();
            }
            // Always ensure title state is synchronized
            debouncedUpdateToc();
        }

        // Function to remove existing ToC from content
        function removeExistingToc(content) {
            if (!content) return content;

            // 1. Try to find ToC by Markers (Robust Method)
            const markerPattern = new RegExp('<!-- TOC_START -->[\\s\\S]*?<!-- TOC_END -->\\n*');
            if (markerPattern.test(content)) {
                return content.replace(markerPattern, '');
            }

            // 2. Fallback: heuristic detection (Legacy/Safe Mode)

            // Get current language and ToC title
            const currentLang = localStorage.getItem('lang') || 'zh';
            const tocTitle = (typeof translations !== 'undefined' && translations[currentLang] && translations[currentLang]['toc_title_in_doc'])
                ? translations[currentLang]['toc_title_in_doc']
                : (currentLang === 'zh' ? '生成目录' : 'Table of Contents');

            // Escape special regex characters in tocTitle
            const escapedTitle = tocTitle.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

            // Find header: ## Table of Contents
            const tocHeaderPattern = new RegExp(`(^|\\n)##\\s+${escapedTitle}\\s*(\\n|$)`);
            const match = content.match(tocHeaderPattern);

            if (!match) {
                return content; // No ToC found
            }

            const headerIndex = match.index + (match[1] ? match[1].length : 0);
            const afterHeader = content.substring(headerIndex + match[0].length);

            // Find end of ToC:
            // It ends when we hit something that is NOT a list item or a blank line
            // List item regex: starts with optional space, dash/star/plus or number dot, then space and link
            const listLinePattern = /^\s*([-*+]|\d+\.)\s+\[/;

            const lines = afterHeader.split('\n');
            let lineCountToRemove = 0;

            // We assume the header line itself is part of ToC and should be removed
            // Now check subsequent lines
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line.trim() === '') {
                    // Blank lines are part of ToC block
                    lineCountToRemove++;
                    continue;
                }
                if (listLinePattern.test(line)) {
                    // List item is part of ToC
                    lineCountToRemove++;
                    continue;
                }
                // Found something that is not blank and not a list item -> End of ToC
                break;
            }

            // Reconstruct content
            // content before header
            const before = content.substring(0, headerIndex);
            // content after header + removed lines
            // We need to calculate the index. 
            // afterHeader starts after match[0]. 
            // We processed 'lineCountToRemove' lines from 'lines' array.
            // join them back to get length?
            const removedPart = lines.slice(0, lineCountToRemove).join('\n');
            // Total length to remove from afterHeader start
            // +1 for the newline after last processed line if we didn't reach end
            const endOffset = removedPart.length + (lineCountToRemove > 0 ? 1 : 0);

            // Actually, simplified:
            // just join remaining lines
            const remainingLines = lines.slice(lineCountToRemove).join('\n');

            return (before + '\n\n' + remainingLines).replace(/\n{3,}/g, '\n\n');
        }

        // Update ToC in document (auto-insert/update)
        function updateTocInDocument() {
            const shouldInsert = document.getElementById('toc-insert').checked;
            if (!shouldInsert) {
                return;
            }

            const input = document.getElementById('markdown-input');
            let content = input.value;

            // Always re-read the level value to ensure it's current
            let levels = parseInt(document.getElementById('toc-levels').value) || 3;
            // Validate level range
            if (levels < 1) levels = 1;
            if (levels > 10) levels = 10;

            // Always try to remove existing ToC first (whether tocInserted is true or not)
            // This handles the case where user manually inserted ToC or modified it
            content = removeExistingToc(content);

            // If we successfully removed a ToC, update the state
            if (tocInserted && originalContent) {
                // Content has been cleaned, update originalContent
                originalContent = content;
            } else if (!tocInserted) {
                // First time inserting, store original content
                originalContent = content;
            }

            // Generate new ToC based on current content (without existing ToC)
            // Use the validated levels value
            const toc = generateTocContent(levels, content);

            // Insert ToC at the beginning
            input.value = toc + content;
            tocInserted = true;

            // Immediately update preview after inserting ToC, but skip hash scroll
            updatePreview(false, true);
        }

        // Remove ToC from document
        function removeTocFromDocument() {
            if (tocInserted && originalContent) {
                const input = document.getElementById('markdown-input');
                input.value = originalContent;
                tocInserted = false;
                originalContent = '';
                updatePreview();
            }
        }

        // Debounced ToC update
        function debouncedUpdateToc() {
            if (tocUpdateTimer) {
                clearTimeout(tocUpdateTimer);
            }
            tocUpdateTimer = setTimeout(() => {
                const tocEnabled = document.getElementById('toc-insert').checked;
                const autoTitleEnabled = document.getElementById('export-auto-title').checked;

                // 1. Handle ToC insertion/update
                if (tocEnabled) {
                    updateTocInDocument();
                }

                // 2. Handle Title update (Independent of ToC)
                if (autoTitleEnabled) {
                    const input = document.getElementById('markdown-input');
                    const firstHeading = getFirstActualHeadingFromMarkdown(input.value);
                    if (firstHeading) {
                        document.title = firstHeading;
                    } else {
                        document.title = originalPageTitle;
                    }
                } else {
                    // Only restore default title if auto-fill is disabled
                    document.title = originalPageTitle;
                }
            }, 500); // Wait 500ms after user stops typing
        }

        function generateTocContent(maxLevel, content) {
            // Use provided content or get from input
            const markdown = content || document.getElementById('markdown-input').value;

            // Helper function to convert string to markdown link format
            // This should match the createSlug function used in marked renderer
            function strToMarkdownTitle(str) {
                if (!str) return '';

                // Use the same logic as createSlug to ensure consistency
                let slug = String(str).trim();

                // Replace spaces and underscores with hyphens
                slug = slug.replace(/[\s_]+/g, '-');

                // Remove leading/trailing hyphens
                slug = slug.replace(/^-+|-+$/g, '');

                // Normalize multiple hyphens
                slug = slug.replace(/-+/g, '-');

                // If slug is empty after processing, generate a fallback
                if (!slug) {
                    slug = 'heading-' + Math.random().toString(36).substr(2, 9);
                }

                return slug;
            }

            // Get current language and translation
            const currentLang = localStorage.getItem('lang') || 'zh';
            const tocTitle = (typeof translations !== 'undefined' && translations[currentLang] && translations[currentLang]['toc_title_in_doc'])
                ? translations[currentLang]['toc_title_in_doc']
                : (currentLang === 'zh' ? '生成目录' : 'Table of Contents');

            // Add markers for robust detection
            const menus = [`<!-- TOC_START -->`, `## ${tocTitle}`, ""];
            let isCodeBlock = false;
            let topLevel = NaN;
            let previous = null;
            const lines = markdown.split("\n");

            // Normalize tocTitle for comparison (to skip it in the ToC list)
            const normalizedTocTitle = tocTitle.toLowerCase().trim();

            for (let line of lines) {
                const trimmed = line.trim();

                // Track code blocks to skip them
                if (trimmed.startsWith("```")) {
                    isCodeBlock = !isCodeBlock;
                }

                if (isCodeBlock) {
                    continue;
                }

                let level = NaN;
                let title = null;

                // Check for ATX-style headers: ## My Header
                if (trimmed.startsWith("#")) {
                    const match = trimmed.match(/(#+)\s*(.*?)#*\s*$/);
                    if (match) {
                        level = match[1].length;
                        title = match[2].trim();
                    }
                } else if (previous != null && previous.length > 0 && trimmed.length > 0) {
                    // Check for Setext-style headers
                    if (trimmed.match(/[^=]/g) == null) {
                        level = 1;
                        title = previous;
                    } else if (trimmed.match(/[^-]/g) == null && previous.match(/[^-]/g) != null) {
                        level = 2;
                        title = previous;
                    }
                }

                if (!isNaN(level) && title != null && title !== "") {
                    // Skip the ToC title itself to avoid duplicate entries
                    const normalizedTitle = title.toLowerCase().trim();
                    if (normalizedTitle === normalizedTocTitle) {
                        previous = null;
                        continue;
                    }

                    if (isNaN(topLevel)) {
                        topLevel = level;
                    }

                    // Only include levels up to maxLevel relative to topLevel
                    // Ensure indentLevel is non-negative
                    const indentLevel = Math.max(0, level - topLevel);
                    if (indentLevel < maxLevel) {
                        // Generate ToC entry
                        const link = strToMarkdownTitle(title);
                        // Use 2 spaces per level for proper Markdown list indentation
                        const indent = "  ".repeat(indentLevel);
                        const menu = `${indent}- [${title}](#${link})`;
                        menus.push(menu);
                    }

                    previous = null;
                } else {
                    previous = trimmed;
                }
            }

            return menus.join("\n") + "\n\n<!-- TOC_END -->\n\n";
        }


        function copyTocToClipboard() {
            // Always re-read the level value to ensure it's current
            let levels = parseInt(document.getElementById('toc-levels').value) || 3;
            // Validate level range
            if (levels < 1) levels = 1;
            if (levels > 10) levels = 10;

            const input = document.getElementById('markdown-input');
            // Get content without ToC if it exists
            const content = (tocInserted && originalContent) ? originalContent : input.value;
            const toc = generateTocContent(levels, content);
            navigator.clipboard.writeText(toc).then(() => {
                const btn = event.target;
                const originalText = btn.textContent;
                const currentLang = localStorage.getItem('lang') || 'zh';
                btn.textContent = currentLang === 'zh' ? '已复制!' : 'Copied!';
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 1500);
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }

        function copyHtmlToClipboard() {
            const output = document.getElementById('preview-output');
            const html = output.innerHTML;
            navigator.clipboard.writeText(html).then(() => {
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 1500);
            });
        }


        // Helper to prepare content for export (Convert SVG/MathJax to Images)
        async function prepareContentForExport(sourceElement) {
            // 1. Clone the content
            const clone = sourceElement.cloneNode(true);

            // We need to work with the visible DOM for canvas sizing, 
            // but we want to modify the clone. 
            // Strategy: Render mapped items from original DOM to canvas, then replace in Clone.

            // A. Handle SVGs (Mermaid)
            const originalSvgs = sourceElement.querySelectorAll('svg');
            const cloneSvgs = clone.querySelectorAll('svg');

            for (let i = 0; i < originalSvgs.length; i++) {
                const originalSvg = originalSvgs[i];
                const cloneSvg = cloneSvgs[i];
                if (!originalSvg || !cloneSvg) continue;

                try {
                    const rect = originalSvg.getBoundingClientRect();
                    if (rect.width === 0 || rect.height === 0) continue;

                    const serializer = new XMLSerializer();
                    const svgStr = serializer.serializeToString(originalSvg);
                    const svgBlob = new Blob([svgStr], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(svgBlob);

                    const img = new Image();
                    img.src = url;

                    await new Promise((resolve) => {
                        img.onload = () => resolve();
                        img.onerror = () => resolve(); // Skip if fail
                    });

                    const canvas = document.createElement('canvas');
                    // High DPI
                    const scale = 2;
                    canvas.width = rect.width * scale;
                    canvas.height = rect.height * scale;
                    const ctx = canvas.getContext('2d');
                    ctx.scale(scale, scale);
                    ctx.drawImage(img, 0, 0, rect.width, rect.height);

                    const imgTag = document.createElement('img');
                    imgTag.src = canvas.toDataURL('image/png');
                    imgTag.style.maxWidth = '100%';
                    imgTag.style.width = originalSvg.style.width || '100%';

                    if (cloneSvg.parentNode) {
                        cloneSvg.parentNode.replaceChild(imgTag, cloneSvg);
                    }
                    URL.revokeObjectURL(url);
                } catch (e) {
                    console.error("SVG conversion failed", e);
                }
            }

            // B. Handle MathJax (CHTML usually)
            // html2canvas struggles with CHTML. We can try to rely on html2pdf's internal canvas 
            // but often it misses fonts. 
            // Best bet: If html2pdf is failing, we might need to rely on the fact that 
            // MathJax v3 output is complex.
            // Let's try to identify MathJax containers and rasterize them using html2canvas individually?
            // Or simpler: Just rely on clean CSS for PDF.
            // User reported "Garbled" -> likely encoding or font issue.
            // Let's try converting MathJax to SVG output in settings? No, that requires reload.
            // Rasterizing MathJax nodes:
            if (window.html2canvas) {
                const mathNodes = sourceElement.querySelectorAll('.MathJax');
                const cloneMathNodes = clone.querySelectorAll('.MathJax');

                for (let i = 0; i < mathNodes.length; i++) {
                    const node = mathNodes[i];
                    const cloneNode = cloneMathNodes[i];
                    if (!node || !cloneNode) continue;

                    try {
                        const canvas = await html2canvas(node, {
                            scale: 2,
                            backgroundColor: null
                        });
                        const imgTag = document.createElement('img');
                        imgTag.src = canvas.toDataURL('image/png');
                        imgTag.style.display = 'inline-block';
                        imgTag.style.maxHeight = '100%';

                        if (cloneNode.parentNode) {
                            cloneNode.parentNode.replaceChild(imgTag, cloneNode);
                        }
                    } catch (e) {
                        console.error("MathJax conversion failed", e);
                    }
                }
            }

            return clone;
        }

        // Download as Markdown
        function downloadMarkdown() {
            const input = document.getElementById('markdown-input');
            const markdown = input.value;
            const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = getDocTitle() + '.md';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Download as Word (DOCX)
        function downloadWord() {
            const output = document.getElementById('preview-output');
            const currentFont = output.style.fontFamily || document.getElementById('font-selector').value || "'Microsoft YaHei', sans-serif";
            const currentBgColor = output.style.backgroundColor || document.getElementById('bg-color').value || '#ffffff';
            const currentStyle = getCurrentStyle();

            // Get computed styles from preview
            const computedStyle = window.getComputedStyle(output);
            const textColor = computedStyle.color || '#000';
            const lineHeight = computedStyle.lineHeight || '1.6';

            // Create a complete HTML document for conversion matching preview
            const htmlContent = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <style>
        body { 
            font-family: ${currentFont}; 
            line-height: ${lineHeight}; 
            color: ${textColor}; 
            background: ${currentBgColor}; 
            padding: 40px; 
            margin: 0;
        }
        h1, h2, h3, h4, h5, h6 { 
            color: ${textColor}; 
            margin-top: 1.5em; 
            margin-bottom: 0.5em; 
        }
        h1 { 
            font-size: 2em; 
            border-bottom: ${currentStyle === 'hacker' ? '2px solid #333' : '2px solid #000'}; 
            padding-bottom: 0.3em; 
        }
        h2 { 
            font-size: 1.5em; 
            border-bottom: ${currentStyle === 'hacker' ? '1px solid #333' : '1px solid #eee'}; 
            padding-bottom: 0.3em; 
        }
        h3 { font-size: 1.25em; }
        code { 
            background: ${currentStyle === 'hacker' ? '#111' : '#f4f4f4'}; 
            padding: 2px 6px; 
            border-radius: 3px; 
            font-family: 'Consolas', 'Monaco', monospace; 
            border: ${currentStyle === 'hacker' ? '1px solid #333' : 'none'};
        }
        pre { 
            background: ${currentStyle === 'hacker' ? '#282c34' : '#f4f4f4'}; 
            padding: 15px; 
            border-radius: 5px; 
            overflow-x: auto; 
            border: ${currentStyle === 'hacker' ? '1px solid #333' : 'none'};
        }
        pre code { 
            background: none; 
            padding: 0; 
            border: none;
        }
        blockquote { 
            border-left: ${currentStyle === 'hacker' ? '4px solid #333' : currentStyle === 'modern' ? '4px solid #3498db' : '4px solid #ccc'}; 
            margin-left: 0; 
            padding-left: 20px; 
            color: ${currentStyle === 'hacker' ? '#7f8c8d' : '#666'}; 
        }
        table { 
            border-collapse: collapse; 
            width: 100%; 
            margin: 1em 0; 
            border: ${currentStyle === 'hacker' ? '1px solid #333' : '1px solid #ddd'};
        }
        th, td { 
            border: ${currentStyle === 'hacker' ? '1px solid #333' : '1px solid #ddd'}; 
            padding: 8px 12px; 
            text-align: left; 
        }
        th { 
            background: ${currentStyle === 'hacker' ? '#111' : currentStyle === 'professional' ? '#2c3e50' : '#f4f4f4'}; 
            color: ${currentStyle === 'professional' ? '#ffffff' : 'inherit'};
            font-weight: bold; 
        }
        tr:nth-child(even) {
            background: ${currentStyle === 'hacker' ? '#0a0a0a' : '#f9f9f9'};
        }
        img { max-width: 100%; height: auto; }
        a { 
            color: ${currentStyle === 'hacker' ? '#00b8ff' : '#0066cc'}; 
            text-decoration: none; 
        }
        a:hover { text-decoration: underline; }
        ul, ol { padding-left: 2em; margin: 1em 0; }
        li { margin: 0.5em 0; }
        hr { 
            margin: 2em 0; 
            border: none; 
            border-top: ${currentStyle === 'hacker' ? '1px solid #333' : '1px solid #eee'}; 
        }
    </style>
</head>
<body>
${output.innerHTML}
</body>
</html>`;

            // Convert to DOCX using html-docx-js
            if (typeof htmlDocx !== 'undefined') {
                const converted = htmlDocx.asBlob(htmlContent);
                const url = URL.createObjectURL(converted);
                const a = document.createElement('a');
                a.href = url;
                a.download = getFilenameFromFirstHeading('.docx');
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } else {
                alert('Word export library not loaded. Please refresh the page.');
            }
        }

        // Download as HTML
        function downloadHTML() {
            const output = document.getElementById('preview-output');
            const currentFont = output.style.fontFamily || document.getElementById('font-selector').value || "'Microsoft YaHei', sans-serif";
            const currentBgColor = output.style.backgroundColor || document.getElementById('bg-color').value || '#ffffff';
            const currentStyle = getCurrentStyle();

            // Get computed styles from preview to match exactly
            const computedStyle = window.getComputedStyle(output);
            const textColor = computedStyle.color || '#000';
            const lineHeight = computedStyle.lineHeight || '1.6';

            // Create a complete standalone HTML document matching preview styles
            const htmlContent = `<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown Document</title>
    <style>
        body {
            font-family: ${currentFont};
            line-height: ${lineHeight};
            color: ${textColor};
            background: ${currentBgColor};
            max-width: 900px;
            margin: 0 auto;
            padding: 40px 20px;
        }
        h1, h2, h3, h4, h5, h6 { 
            margin-top: 1.5em; 
            margin-bottom: 0.5em; 
            font-weight: bold;
        }
        h1 { 
            font-size: 2em; 
            border-bottom: ${currentStyle === 'hacker' ? '2px solid #333' : '2px solid #333'}; 
            padding-bottom: 0.3em; 
        }
        h2 { 
            font-size: 1.5em; 
            border-bottom: ${currentStyle === 'hacker' ? '1px solid #333' : '1px solid #eee'}; 
            padding-bottom: 0.3em; 
        }
        h3 { font-size: 1.25em; }
        code { 
            background: ${currentStyle === 'hacker' ? '#111' : '#f4f4f4'}; 
            padding: 2px 6px; 
            border-radius: 3px; 
            font-family: 'Consolas', 'Monaco', monospace; 
            border: ${currentStyle === 'hacker' ? '1px solid #333' : 'none'};
        }
        pre { 
            background: ${currentStyle === 'hacker' ? '#282c34' : '#f4f4f4'}; 
            padding: 15px; 
            border-radius: 5px; 
            overflow-x: auto; 
            border: ${currentStyle === 'hacker' ? '1px solid #333' : 'none'};
        }
        pre code { 
            background: none; 
            padding: 0; 
            border: none;
        }
        blockquote { 
            border-left: ${currentStyle === 'hacker' ? '4px solid #333' : currentStyle === 'modern' ? '4px solid #3498db' : '4px solid #ddd'}; 
            margin-left: 0; 
            padding-left: 20px; 
            color: ${currentStyle === 'hacker' ? '#7f8c8d' : '#666'}; 
            font-style: italic; 
        }
        table { 
            border-collapse: collapse; 
            width: 100%; 
            margin: 1em 0; 
            border: ${currentStyle === 'hacker' ? '1px solid #333' : '1px solid #ddd'};
        }
        th, td { 
            border: ${currentStyle === 'hacker' ? '1px solid #333' : '1px solid #ddd'}; 
            padding: 8px 12px; 
            text-align: left; 
        }
        th { 
            background: ${currentStyle === 'hacker' ? '#111' : currentStyle === 'professional' ? '#2c3e50' : '#f4f4f4'}; 
            color: ${currentStyle === 'professional' ? '#ffffff' : 'inherit'};
            font-weight: bold; 
        }
        tr:nth-child(even) {
            background: ${currentStyle === 'hacker' ? '#0a0a0a' : '#f9f9f9'};
        }
        img { 
            max-width: 100%; 
            height: auto; 
            display: block; 
            margin: 1em 0; 
        }
        a { 
            color: ${currentStyle === 'hacker' ? '#00b8ff' : '#0066cc'}; 
            text-decoration: none; 
        }
        a:hover { text-decoration: underline; }
        ul, ol { 
            padding-left: 2em; 
            margin: 1em 0; 
        }
        li { margin: 0.5em 0; }
        hr { 
            margin: 2em 0; 
            border: none; 
            border-top: ${currentStyle === 'hacker' ? '1px solid #333' : '1px solid #eee'}; 
        }
    </style>
</head>
<body>
${output.innerHTML}
</body>
</html>`;

            const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = getDocTitle() + '.html';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Download PDF using html2pdf + pdf-lib (Byte-level Watermark)
        async function downloadPDFWithLib() {
            const output = document.getElementById('preview-output');
            const watermarkText = document.getElementById('watermark-text').value;
            const watermarkType = document.getElementById('watermark-type').value;

            // 1. Prepare Content (Pre-render complex items)
            // Note: html2pdf processes the element from DOM. 
            // If we use 'clone', we must temporarily append it to DOM or use html2pdf's source handling carefully.
            // html2pdf can take a string or element.
            // Best approach: Temporarily replace output content or append clone hidden?
            // Actually, html2pdf needs the element to be rendered to calculate layout.
            // Swapping content in visible DOM causes flash.
            // Overlay approach: Create a temporary container off-screen but visible?

            // Simplified: We'll modify a clone, but since html2pdf needs layout, 
            // we might just use the original output for layout, OR
            // we rely on the fact that we just converted things to images which render fine in offscreen/clone if styles are matched.

            // Let's try: Generate content-rich clone, append to body (hidden visibility), PDF it, remove it.
            const clone = await prepareContentForExport(output);

            // Apply current styles to clone wrapper to ensure font consistency
            const wrapper = document.createElement('div');
            wrapper.className = 'markdown-body'; // standard class
            // Copy styles
            wrapper.style.fontFamily = output.style.fontFamily;
            wrapper.style.backgroundColor = output.style.backgroundColor || '#fff';
            wrapper.style.color = window.getComputedStyle(output).color;
            wrapper.style.padding = '40px';
            wrapper.style.width = '210mm'; // A4 width approx
            wrapper.style.position = 'absolute';
            wrapper.style.left = '-9999px';
            // wrapper.style.visibility = 'hidden'; // html2canvas sometimes ignores hidden
            wrapper.appendChild(clone);
            document.body.appendChild(wrapper);

            const opt = {
                margin: [10, 10, 10, 10], // mm
                filename: getDocTitle() + '.pdf',
                image: { type: 'jpeg', quality: 0.98 },
                html2canvas: { scale: 2, useCORS: true },
                jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
            };

            try {
                // Generate PDF as ArrayBuffer
                const worker = html2pdf().set(opt).from(clone).toPdf();
                const pdfDoc = await worker.get('pdf'); // jsPDF object
                const pdfBytes = await pdfDoc.output('arraybuffer');

                // 2. Modify PDF with pdf-lib
                const { PDFDocument, rgb, degrees } = PDFLib;
                const pdf = await PDFDocument.load(pdfBytes);
                const pages = pdf.getPages();

                // Draw text on each page
                for (const page of pages) {
                    const { width, height } = page.getSize();

                    if (watermarkType === 'full') {
                        // Tiled Pattern - Tuned for less overlap
                        // 2x2 or 2x3 grid is usually enough for A4
                        const cols = 2;
                        const rows = 3;
                        const xGap = width / cols;
                        const yGap = height / rows;

                        for (let i = 0; i < cols; i++) {
                            for (let j = 0; j < rows; j++) {
                                // Offset odd rows for aesthetic
                                const xOffset = (j % 2 === 0) ? 0 : xGap / 2;

                                page.drawText(watermarkText, {
                                    x: (i * xGap) + xOffset + 40,
                                    y: (j * yGap) + 80,
                                    size: 20, // Reduced from 24
                                    color: rgb(0.6, 0.6, 0.6),
                                    opacity: 0.15, // Reduced opacity
                                    rotate: degrees(45),
                                });
                            }
                        }
                    } else {
                        // Footer
                        page.drawText(watermarkText, {
                            x: width - 200,
                            y: 20,
                            size: 10,
                            color: rgb(0.5, 0.5, 0.5),
                            opacity: 0.5,
                        });
                    }
                }

                // 3. Save and Download
                const modifiedPdfBytes = await pdf.save();
                const blob = new Blob([modifiedPdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);

                // Preview in new tab (User requested "preview")
                const previewWindow = window.open(url, '_blank');
                if (!previewWindow) {
                    // Fallback to download if popup blocked
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = getDocTitle() + '.pdf';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                }

                // Small delay to revoke
                setTimeout(() => URL.revokeObjectURL(url), 60000);

            } catch (err) {
                console.error("PDF Generation Failed:", err);
                alert("PDF Generation Failed. Falling back to Browser Print.");
                window.print();
            } finally {
                // Cleanup DOM
                document.body.removeChild(wrapper);
            }
        }

        // Helper to get document title for Exports
        function getDocTitle() {
            const autoTitleEnabled = document.getElementById('export-auto-title').checked;
            if (autoTitleEnabled) {
                const firstHeading = getFirstActualHeading();
                if (firstHeading) {
                    return firstHeading.textContent.trim();
                }
            }
            return originalPageTitle; // Default: "Markdown to PDF" or similar
        }

        // Update output behavior
        function updateExportMode() {
            const format = document.getElementById('export-format').value;
            const output = document.getElementById('preview-output');

            if (format === 'pdf-mobile') {
                output.classList.add('mobile-pdf-mode');
            } else {
                output.classList.remove('mobile-pdf-mode');
            }
        }

        // Handle Export based on selected format
        function handleExport() {
            const format = document.getElementById('export-format').value;

            if (format === 'md') {
                downloadMarkdown();
            } else if (format === 'html') {
                downloadHTML();
            } else if (format === 'docx') {
                downloadWord();
            } else if (format === 'pdf' || format === 'pdf-mobile') {
                const autoTitleEnabled = document.getElementById('export-auto-title').checked;
                const watermarkEnabled = document.getElementById('enable-watermark').checked;

                // Use Byte-level processing if Watermark is enabled (User Request)
                // Otherwise use native Print for best quality
                if (watermarkEnabled && format === 'pdf') {
                    downloadPDFWithLib();
                    return;
                }

                document.title = getDocTitle();

                if (format === 'pdf-mobile') {
                    document.body.classList.add('mobile-pdf-mode-active');
                }

                window.print();

                // Cleanup after print dialog
                if (format === 'pdf-mobile') {
                    // Slight delay to ensure print dialog has picked up styles
                    setTimeout(() => {
                        document.body.classList.remove('mobile-pdf-mode-active');
                    }, 500);
                }

                // Restore original title
                setTimeout(() => {
                    document.title = originalPageTitle;
                }, 1000);
            }
            if (backgroundColor) {
                output.style.setProperty('background-color', backgroundColor, 'important');
                // Force color printing
                output.style.setProperty('-webkit-print-color-adjust', 'exact', 'important');
                output.style.setProperty('print-color-adjust', 'exact', 'important');
            }
            if (color) {
                output.style.setProperty('color', color, 'important');
            }
            if (lineHeight) {
                output.style.setProperty('line-height', lineHeight, 'important');
            }

            // Ensure all child elements also preserve their styles
            const allElements = output.querySelectorAll('*');
            allElements.forEach(el => {
                const elStyle = window.getComputedStyle(el);

                // Preserve code block backgrounds (pre and .hljs)
                if (el.tagName === 'PRE' || el.classList.contains('hljs')) {
                    const bg = elStyle.backgroundColor;
                    if (bg && bg !== 'rgba(0, 0, 0, 0)' && bg !== 'transparent') {
                        el.style.setProperty('background-color', bg, 'important');
                        el.style.setProperty('-webkit-print-color-adjust', 'exact', 'important');
                        el.style.setProperty('print-color-adjust', 'exact', 'important');
                    }
                    // Also preserve border color
                    const borderColor = elStyle.borderColor;
                    if (borderColor && borderColor !== 'rgba(0, 0, 0, 0)') {
                        el.style.setProperty('border-color', borderColor, 'important');
                    }
                }

                // Preserve ALL highlight.js syntax highlighting colors
                // Check if element has any hljs- class
                const hasHljsClass = Array.from(el.classList).some(cls => cls.startsWith('hljs-'));
                if (hasHljsClass) {
                    const textColor = elStyle.color;
                    if (textColor && textColor !== 'rgb(0, 0, 0)' && textColor !== 'rgba(0, 0, 0, 0)') {
                        el.style.setProperty('color', textColor, 'important');
                        el.style.setProperty('-webkit-print-color-adjust', 'exact', 'important');
                        el.style.setProperty('print-color-adjust', 'exact', 'important');
                    }
                }

                // Preserve inline code backgrounds
                if (el.tagName === 'CODE' && !el.closest('pre')) {
                    const bg = elStyle.backgroundColor;
                    if (bg && bg !== 'rgba(0, 0, 0, 0)' && bg !== 'transparent') {
                        el.style.setProperty('background-color', bg, 'important');
                        el.style.setProperty('-webkit-print-color-adjust', 'exact', 'important');
                        el.style.setProperty('print-color-adjust', 'exact', 'important');
                    }
                    const textColor = elStyle.color;
                    if (textColor) {
                        el.style.setProperty('color', textColor, 'important');
                    }
                }
            });

            // Ensure Mermaid diagrams (all types: flowchart, classDiagram, sequenceDiagram, etc.) are properly sized for print
            const mermaidElements = output.querySelectorAll('.mermaid');
            mermaidElements.forEach(mermaidEl => {
                // Ensure container has proper styling
                mermaidEl.style.setProperty('display', 'block', 'important');
                mermaidEl.style.setProperty('width', '100%', 'important');
                mermaidEl.style.setProperty('max-width', '100%', 'important');
                mermaidEl.style.setProperty('margin', '2em 0', 'important');
                mermaidEl.style.setProperty('padding', '1em 0', 'important');
                mermaidEl.style.setProperty('page-break-inside', 'avoid', 'important');
                mermaidEl.style.setProperty('page-break-after', 'auto', 'important');
                mermaidEl.style.setProperty('overflow', 'hidden', 'important');
                mermaidEl.style.setProperty('box-sizing', 'border-box', 'important');

                // Limit SVG size within Mermaid containers (works for all diagram types)
                const svgElements = mermaidEl.querySelectorAll('svg');
                svgElements.forEach(svg => {
                    // Get actual SVG dimensions
                    const svgWidthAttr = svg.getAttribute('width');
                    const svgHeightAttr = svg.getAttribute('height');
                    const svgViewBox = svg.getAttribute('viewBox');

                    let svgWidth = null;
                    let svgHeight = null;

                    // Try to get dimensions from attributes first
                    if (svgWidthAttr && !isNaN(parseFloat(svgWidthAttr))) {
                        svgWidth = parseFloat(svgWidthAttr);
                    }
                    if (svgHeightAttr && !isNaN(parseFloat(svgHeightAttr))) {
                        svgHeight = parseFloat(svgHeightAttr);
                    }

                    // If not available, try viewBox
                    if (!svgWidth || !svgHeight) {
                        if (svgViewBox) {
                            const viewBoxParts = svgViewBox.split(/\s+/);
                            if (viewBoxParts.length >= 4) {
                                svgWidth = parseFloat(viewBoxParts[2]);
                                svgHeight = parseFloat(viewBoxParts[3]);
                            }
                        }
                    }

                    // If still not available, use computed style
                    if (!svgWidth || !svgHeight) {
                        const svgStyle = window.getComputedStyle(svg);
                        svgWidth = parseFloat(svgStyle.width) || svg.clientWidth;
                        svgHeight = parseFloat(svgStyle.height) || svg.clientHeight;
                    }

                    // Maximum dimensions for print (considering page margins)
                    const maxPrintWidth = 700; // Leave room for page margins
                    const maxPrintHeight = 500; // Limit height to prevent overlap

                    // Calculate scale if needed
                    let scale = 1;
                    if (svgWidth && svgHeight) {
                        const widthScale = svgWidth > maxPrintWidth ? maxPrintWidth / svgWidth : 1;
                        const heightScale = svgHeight > maxPrintHeight ? maxPrintHeight / svgHeight : 1;
                        scale = Math.min(widthScale, heightScale);
                    }

                    // Apply scaling if needed
                    if (scale < 1 && svgWidth && svgHeight) {
                        const newWidth = svgWidth * scale;
                        const newHeight = svgHeight * scale;

                        // Set explicit dimensions
                        svg.setAttribute('width', newWidth);
                        svg.setAttribute('height', newHeight);
                        svg.style.setProperty('width', newWidth + 'px', 'important');
                        svg.style.setProperty('height', newHeight + 'px', 'important');
                    } else {
                        // Just ensure max constraints
                        svg.style.setProperty('max-width', '100%', 'important');
                        svg.style.setProperty('width', '100%', 'important');
                        svg.style.setProperty('height', 'auto', 'important');
                    }

                    // Always set max constraints
                    svg.style.setProperty('max-width', maxPrintWidth + 'px', 'important');
                    svg.style.setProperty('max-height', maxPrintHeight + 'px', 'important');
                    svg.style.setProperty('display', 'block', 'important');
                    svg.style.setProperty('margin', '0 auto', 'important');
                    svg.style.setProperty('page-break-inside', 'avoid', 'important');
                    svg.style.setProperty('box-sizing', 'border-box', 'important');
                    svg.style.setProperty('overflow', 'visible', 'important');
                });

                // Also handle any nested containers or wrappers
                const mermaidContainers = mermaidEl.querySelectorAll('div, span');
                mermaidContainers.forEach(container => {
                    if (container.querySelector('svg')) {
                        container.style.setProperty('max-width', '100%', 'important');
                        container.style.setProperty('overflow', 'hidden', 'important');
                    }
                });
            });

            setTimeout(() => {
                window.print();

                // cleanup
                if (format === 'pdf-mobile') {
                    // Delay cleanup to ensure print dialog captures the style
                    // Note: Browsers block JS during print dialog, so this runs after
                    // Only remove if it wasn't selected by user in UI
                    if (document.getElementById('export-format').value !== 'pdf-mobile') {
                        output.classList.remove('mobile-pdf-mode');
                    }
                    document.body.classList.remove('mobile-pdf-mode-active');
                }
            }, 100);
        }


        // Editor Introduction Text
        const editorIntro = `# Markdown Editor

## 🇨🇳 中文说明

### 🎯 功能概览

#### 1. 核心功能
- **实时预览**：左侧编辑，右侧实时预览
- **GitHub Flavored Markdown (GFM)**：完整支持 GFM 语法
- **语法高亮**：自动识别并高亮代码块

#### 2. 样式与主题
- 📄 **Academic**：学术风格
- 💼 **Business**：商务风格
- 💻 **Hacker**：黑客风格

#### 3. 高级功能

##### 代码块支持
- 支持多种编程语言语法高亮
- 支持 Mermaid 图表（流程图、甘特图、序列图等）
- 支持 LaTeX 数学公式

##### 目录生成
- 自动生成目录
- 可自定义显示层级（1-6级）
- 支持插入目录或复制到剪贴板

##### 导出功能
- 📄 Markdown (.md)
- 🌐 HTML (.html)
- 📝 Word (.docx)
- 📑 PDF（打印）

#### 4. 语法检查
- 自动检测代码块前的空格错误
- 检测未闭合的代码块
- 检测表格格式错误
- 悬浮或点击行号查看错误详情

### ⚠️ 注意事项

#### 代码块格式
- 代码块标记 \`\`\` 必须从行首开始，不能有前导空格
- 确保代码块有开始和结束标记

示例：
\`\`\`python
print("Hello World")
\`\`\`

#### 表格格式
- 使用 | 分隔列
- 使用 - 或 : 创建分隔行
- 确保每行有相同数量的列

---

## 🇬🇧 English Guide

### 🎯 Features Overview

#### 1. Core Features
- **Real-time Preview**: Edit on the left, preview on the right
- **GitHub Flavored Markdown (GFM)**: Full GFM syntax support
- **Syntax Highlighting**: Automatic code block highlighting

#### 2. Styles & Themes
- 📄 **Academic**: Academic style
- 💼 **Business**: Business style
- 💻 **Hacker**: Hacker style

#### 3. Advanced Features

##### Code Block Support
- Syntax highlighting for multiple programming languages
- Mermaid diagrams (flowcharts, Gantt charts, sequence diagrams, etc.)
- LaTeX mathematical formulas

##### Table of Contents
- Auto-generate table of contents
- Customizable display levels (1-10)
- Insert ToC or copy to clipboard

##### Export Features
- 📄 Markdown (.md)
- 🌐 HTML (.html)
- 📝 Word (.docx)
- 📑 PDF (Print)

#### 4. Syntax Checking
- Auto-detect leading spaces before code blocks
- Detect unclosed code blocks
- Detect table format errors
- Hover or click line numbers to view error details

### ⚠️ Notes

#### Code Block Format
- Code block markers \`\`\` must start at the beginning of the line, no leading spaces
- Ensure code blocks have both opening and closing markers

Example:
\`\`\`python
print("Hello World")
\`\`\`

#### Table Format
- Use | to separate columns
- Use - or : to create separator rows
- Ensure each row has the same number of columns

---

`;

        // Fixed Categorized Examples
        const fixedExamples = `# 📚 Markdown 示例文档

## 📖 目录

1. [基础语法示例](#基础语法示例)
2. [代码示例](#代码示例)
3. [数学公式示例](#数学公式示例)
4. [图表示例](#图表示例)
5. [表格示例](#表格示例)

---

## 📝 基础语法示例

### 标题层级

# 一级标题
## 二级标题
### 三级标题
#### 四级标题

### 文本样式

这是**粗体文本**，这是*斜体文本*，这是~~删除线~~。

### 列表

#### 无序列表
- 项目一
- 项目二
  - 子项目 2.1
  - 子项目 2.2
- 项目三

#### 有序列表
1. 第一步
2. 第二步
3. 第三步

#### 任务列表
- [x] 已完成任务
- [ ] 待完成任务
- [ ] 另一个任务

### 引用

> 这是一段引用文本。
> 
> 可以包含多行内容。
> 
> — 引用来源

### 链接和图片

[链接文本](https://example.com)

![一个灰色的 400x200 占位符图片](data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0MDAiIGhlaWdodD0iMjAwIj48cmVjdCB3aWR0aD0iNDAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2YwZjBmMCIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBkb21pbmFudC1iYXNlbGluZT0ibWlkZGxlIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTgiIGZpbGw9IiM5OTkiPjQwMCB4IDIwMDwvdGV4dD48L3N2Zz4=)


![cat1](data:image/jpeg;base64,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)


---

## 💻 代码示例

### Python 示例

\`\`\`python
def quick_sort(arr):
    """快速排序算法"""
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    return quick_sort(left) + middle + quick_sort(right)

# 使用示例
numbers = [3, 6, 8, 10, 1, 2, 1]
sorted_numbers = quick_sort(numbers)
print(f"排序结果: {sorted_numbers}")
\`\`\`

### JavaScript 示例

\`\`\`javascript
// 异步函数示例
async function fetchUserData(userId) {
    try {
        const response = await fetch(\`/api/users/\${userId}\`);
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('获取用户数据失败:', error);
        throw error;
    }
}

// 使用 Promise
fetchUserData(123)
    .then(user => console.log('用户:', user))
    .catch(err => console.error('错误:', err));
\`\`\`

### Java 示例

\`\`\`java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
        
        // 计算斐波那契数列
        int n = 10;
        for (int i = 0; i < n; i++) {
            System.out.print(fibonacci(i) + " ");
        }
    }
    
    public static int fibonacci(int n) {
        if (n <= 1) return n;
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}
\`\`\`

---

## 🔢 数学公式示例

### 基础公式

行内公式：$E = mc^2$

### 微积分

导数的定义：
$$ f'(x) = \\lim_{h \\to 0} \\frac{f(x+h) - f(x)}{h} $$

定积分：
$$ \\int_a^b f(x)dx = F(b) - F(a) $$

### 线性代数

矩阵乘法：

<div>
$$ (AB)_{ij} = \\sum_{k=1}^n a_{ik}b_{kj} $$
</div>

特征值方程：
$$ \\det(A - \\lambda I) = 0 $$

### 概率论

贝叶斯定理：
$$ P(A|B) = \\frac{P(B|A) \\cdot P(A)}{P(B)} $$

正态分布：
$$ f(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}} $$

---

## 📊 图表示例

### 流程图

\`\`\`mermaid
graph TD
    A[开始] --> B{条件判断}
    B -->|是| C[执行操作A]
    B -->|否| D[执行操作B]
    C --> E[结束]
    D --> E
\`\`\`

### 序列图

\`\`\`mermaid
sequenceDiagram
    participant 用户
    participant 前端
    participant API
    participant 数据库
    
    用户->>前端: 提交表单
    前端->>API: POST /submit
    API->>数据库: 保存数据
    数据库-->>API: 返回结果
    API-->>前端: 响应成功
    前端-->>用户: 显示消息
\`\`\`

### 甘特图

\`\`\`mermaid
gantt
    title 项目开发计划
    dateFormat YYYY-MM-DD
    section 需求分析
    需求调研    :a1, 2024-01-01, 7d
    需求文档    :a2, after a1, 5d
    section 设计阶段
    架构设计    :b1, after a2, 10d
    UI设计      :b2, after a2, 8d
    section 开发阶段
    后端开发    :c1, after b1, 20d
    前端开发    :c2, after b2, 18d
    section 测试阶段
    单元测试    :d1, after c1, 5d
    集成测试    :d2, after c2, 5d
\`\`\`

### 饼图

\`\`\`mermaid
pie title 编程语言使用占比
    "Python" : 35
    "JavaScript" : 28
    "Java" : 20
    "Go" : 10
    "其他" : 7
\`\`\`

### 类图

\`\`\`mermaid
classDiagram
    class User {
        +String name
        +String email
        +login()
        +logout()
    }
    class Order {
        +int id
        +Date date
        +calculateTotal()
    }
    class Product {
        +String name
        +float price
    }
    
    User "1" --> "*" Order
    Order "*" --> "*" Product
\`\`\`

---

## 📋 表格示例

### 基础表格

| 姓名 | 年龄 | 城市 | 职业 |
|------|------|------|------|
| 张三 | 25 | 北京 | 工程师 |
| 李四 | 30 | 上海 | 设计师 |
| 王五 | 28 | 广州 | 产品经理 |

### 对齐表格

| 左对齐 | 居中 | 右对齐 |
|:-------|:----:|-------:|
| 文本1 | 文本2 | 文本3 |
| 数据A | 数据B | 数据C |

### 复杂表格

| 功能 | 支持情况 | 备注 |
|------|:--------:|------|
| Markdown | ✅ 完全支持 | 支持 GFM 语法 |
| 代码高亮 | ✅ 完全支持 | 使用 highlight.js |
| 数学公式 | ✅ 完全支持 | LaTeX 语法 |
| Mermaid 图表 | ✅ 完全支持 | 多种图表类型 |
| 表格 | ✅ 完全支持 | 支持对齐和样式 |

---

## 🎨 其他示例

### 水平线

---

### 代码片段

行内代码：使用 \`console.log()\` 输出信息。

### 转义字符

\\*这不是列表\\*

### HTML 标签

<mark>高亮文本</mark>

<kbd>Ctrl</kbd> + <kbd>C</kbd> 复制

---

*文档结束*`;

        // Old random examples array (kept for reference, but not used)
        const examples = [
            `# 苏格拉底的智慧

## 关于知识

> "我知道我一无所知" —— 苏格拉底

### 核心哲学思想

苏格拉底（公元前470-399年）是古希腊最伟大的哲学家之一。

#### 1. 苏格拉底方法

- **提问式教学**：通过不断提问引导学生发现真理
- **辩证法**：通过对话和辩论来检验观点  
- **揭示矛盾**：暴露思维中的逻辑漏洞

#### 2. 德性即知识

1. 知识是美德的基础
2. 无人自愿作恶
3. 恶行源于无知

### 著名语录

| 原文 | 含义 |
|------|------|
| The unexamined life is not worth living | 未经审视的生活不值得过 |
| To know thyself is the beginning of wisdom | 认识你自己是智慧的开端 |

---

## 对现代的启示

\`\`\`python
def socratic_method(question):
    """苏格拉底式提问"""
    assumptions = analyze(question)
    return refined_understanding
\`\`\``,
            `# 东方哲学精粹

## 老子道德经

> 道可道，非常道；名可名，非常名。

### 主要思想

#### 无为而治

1. **顺应自然**
   - 不强求
   - 不过度干预
   
2. **以柔克刚**
   - 水的智慧
   - 谦卑的力量

### 核心概念

| 概念 | 含义 | 应用 |
|------|------|------|
| 道 | 宇宙本源 | 遵循自然规律 |
| 德 | 道的体现 | 内在修养 |
| 无为 | 不妄为 | 顺势而为 |

---

## 孔子论语

\`\`\`
子曰："己所不欲，勿施于人。"
子曰:"学而不思则罔，思而不学则殆"
\`\`\`

> 温故知新，可以为师矣`,
            `# Project Roadmap

## Q1 2024 Goals

- [ ] Complete API redesign
- [ ] Launch mobile app beta
- [x] Implement user feedback

---

## Performance Metrics

| Metric | Current | Target |
|--------|---------|--------|
| Response Time | 200ms | 100ms |
| Uptime | 99.5% | 99.9% |

## Timeline
\`\`\`mermaid
gantt
    title Project Development
    dateFormat  YYYY-MM-DD
    section Design
    Research           :2023-01-01, 30d
    Prototyping        :2023-02-01, 20d
    section Implementation
    Frontend           :2023-02-21, 45d
    Backend            :2023-03-01, 60d
\`\`\`

## Budget Calculation
The total cost $C$ is calculated as:
$$ C = \\sum_{i=1}^{n} (h_i \\times r_i) + O $$
Where $h_i$ is hours, $r_i$ is rate, and $O$ is overhead.
`,
            `# 数学公式示例

## 微积分基础

### 导数定义
函数 $f(x)$ 在点 $x_0$ 处的导数定义为：
$$ f'(x_0) = \\lim_{h \\to 0} \\frac{f(x_0 + h) - f(x_0)}{h} $$

### 积分计算
定积分的基本定理：
$$ \\int_a^b f(x)dx = F(b) - F(a) $$

其中 $F(x)$ 是 $f(x)$ 的原函数。

## 线性代数

### 矩阵运算
矩阵 $A$ 和 $B$ 的矩阵乘法：

<div>
$$ (AB)_{ij} = \\sum_{k=1}^n a_{ik}b_{kj} $$
</div>

### 特征值
矩阵 $A$ 的特征值 $\\lambda$ 满足：
$$ \\det(A - \\lambda I) = 0 $$

## 概率论

### 贝叶斯定理
$$ P(A|B) = \\frac{P(B|A)P(A)}{P(B)} $$

### 正态分布
概率密度函数：
$$ f(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}} $$

## 物理公式

### 爱因斯坦质能方程
$$ E = mc^2 $$

### 薛定谔方程
$$ i\\hbar\\frac{\\partial}{\\partial t}\\Psi(r,t) = \\hat{H}\\Psi(r,t) $$
`,
            `# 系统架构图

## 微服务架构

\`\`\`mermaid
graph TB
    A[API Gateway] --> B[Auth Service]
    A --> C[User Service]
    A --> D[Order Service]
    A --> E[Payment Service]
    
    B --> F[(Auth DB)]
    C --> G[(User DB)]
    D --> H[(Order DB)]
    E --> I[(Payment DB)]
    
    D --> J[Message Queue]
    E --> J
    J --> K[Notification Service]
\`\`\`

## 用户登录流程

\`\`\`mermaid
sequenceDiagram
    participant U as User
    participant F as Frontend
    participant A as API
    participant D as Database
    
    U->>F: 输入账号密码
    F->>A: POST /login
    A->>D: 验证凭据
    D-->>A: 返回用户信息
    A-->>F: JWT Token
    F-->>U: 登录成功
\`\`\`

## 状态机

\`\`\`mermaid
stateDiagram-v2
    [*] --> Draft
    Draft --> Review: Submit
    Review --> Approved: Approve
    Review --> Rejected: Reject
    Rejected --> Draft: Revise
    Approved --> Published: Publish
    Published --> [*]
\`\`\`

## 类图

\`\`\`mermaid
classDiagram
    class User {
        +String name
        +String email
        +login()
        +logout()
    }
    class Order {
        +int id
        +Date date
        +calculateTotal()
    }
    class Product {
        +String name
        +float price
    }
    
    User "1" --> "*" Order
    Order "*" --> "*" Product
\`\`\`
`,
            `# 算法分析

## 时间复杂度

### 冒泡排序
最坏情况时间复杂度：$O(n^2)$

\`\`\`python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
\`\`\`

### 快速排序
平均时间复杂度：$O(n \\log n)$

递推关系：
$$ T(n) = 2T(\\frac{n}{2}) + O(n) $$

## 决策树

\`\`\`mermaid
graph TD
    A[开始] --> B{n < 2?}
    B -->|Yes| C[返回 n]
    B -->|No| D[计算 fib n-1]
    D --> E[计算 fib n-2]
    E --> F[返回和]
\`\`\`

## 递归公式

斐波那契数列：
$$ F_n = F_{n-1} + F_{n-2} $$
其中 $F_0 = 0, F_1 = 1$

通项公式：
$$ F_n = \\frac{1}{\\sqrt{5}}\\left[\\left(\\frac{1+\\sqrt{5}}{2}\\right)^n - \\left(\\frac{1-\\sqrt{5}}{2}\\right)^n\\right] $$
`,
            `# 数据可视化

## 饼图示例

\`\`\`mermaid
pie title 编程语言使用占比
    "JavaScript" : 35
    "Python" : 25
    "Java" : 20
    "Go" : 12
    "Others" : 8
\`\`\`

## Git工作流

\`\`\`mermaid
gitGraph
    commit
    commit
    branch develop
    checkout develop
    commit
    commit
    checkout main
    merge develop
    commit
    commit
\`\`\`

## 甘特图

\`\`\`mermaid
gantt
    title 项目开发计划
    dateFormat YYYY-MM-DD
    section 需求分析
    需求调研    :a1, 2024-01-01, 7d
    需求文档    :a2, after a1, 5d
    section 设计
    架构设计    :b1, after a2, 10d
    UI设计      :b2, after a2, 8d
    section 开发
    后端开发    :c1, after b1, 20d
    前端开发    :c2, after b2, 18d
\`\`\`

## 统计数据

| 指标 | Q1 | Q2 | Q3 | Q4 |
|------|----|----|----|----|
| 用户增长 | +15% | +23% | +31% | +28% |
| 收入 | $50k | $68k | $82k | $95k |
| MAU | 10k | 15k | 22k | 30k |

增长率计算：
$$ \\text{Growth Rate} = \\frac{V_{\\text{final}} - V_{\\text{initial}}}{V_{\\text{initial}}} \\times 100\\% $$`,
            `# 🧬 Sequence Analysis

## Data Flow
\`\`\`mermaid
sequenceDiagram
    participant U as User
    participant S as Server
    participant D as Database
    U->>S: Request Data
    S->>D: Query
    D-->>S: Results
    S-->>U: Response
\`\`\`

## Probability
The probability of event $A$ given $B$ is:
$$ P(A|B) = \\frac{P(B|A)P(A)}{P(B)} $$
`,
            `# 🌳 Decision Tree

## Logic
\`\`\`mermaid
graph TD
    A[Start] --> B{Is it raining?}
    B -- Yes --> C[Take umbrella]
    B -- No --> D[Enjoy sun]
    C --> E[End]
    D --> E
\`\`\`

## Area of Circle
The area $A$ is given by:
$$ A = \\pi r^2 $$
`
        ];

        // Init - wait for DOM to be ready
        // Global function to handle hash changes and scroll to target in preview
        function handleHashChange() {
            if (!window.location.hash) return;

            const hash = decodeURIComponent(window.location.hash.substring(1));
            const output = document.getElementById('preview-output');
            if (!output) return;

            // Function to find target element by various methods
            // Supports Chinese, emoji, and other UTF-8 characters
            function findTargetElement(id) {
                if (!id) return null;

                // Clean the ID (remove leading/trailing dashes, handle special cases)
                const cleanId = id.replace(/^-+|-+$/g, '');

                // Helper function to safely query selector with UTF-8 characters
                function safeQuerySelector(selector) {
                    try {
                        // Try with CSS.escape
                        return output.querySelector(`#${CSS.escape(selector)}`);
                    } catch (e) {
                        // If CSS.escape fails, try direct query
                        try {
                            return output.querySelector(`#${selector}`);
                        } catch (e2) {
                            // If that also fails, try attribute selector
                            return output.querySelector(`[id="${selector}"]`);
                        }
                    }
                }

                // Try direct ID match (exact)
                let targetElement = safeQuerySelector(id);
                if (targetElement) return targetElement;

                // Try cleaned ID
                targetElement = safeQuerySelector(cleanId);
                if (targetElement) return targetElement;

                // Try URL-encoded version
                try {
                    targetElement = safeQuerySelector(encodeURIComponent(id));
                    if (targetElement) return targetElement;
                } catch (e) {
                    // Ignore
                }

                // Try URL-decoded version
                try {
                    const decodedId = decodeURIComponent(id);
                    targetElement = safeQuerySelector(decodedId);
                    if (targetElement) return targetElement;
                } catch (e) {
                    // Ignore decode errors
                }

                // Try with normalized ID format (preserve UTF-8 characters)
                const normalizedId = id.trim()
                    .replace(/\s+/g, '-')
                    .replace(/-+/g, '-')
                    .replace(/^-+|-+$/g, '');
                targetElement = safeQuerySelector(normalizedId);
                if (targetElement) return targetElement;

                // Try lowercase version (but preserve UTF-8 characters)
                const lowerId = id.toLowerCase();
                if (lowerId !== id) {
                    targetElement = safeQuerySelector(lowerId);
                    if (targetElement) return targetElement;
                }

                // Try all possible variations
                const variations = [
                    id,
                    cleanId,
                    normalizedId,
                    id.replace(/_/g, '-'),
                    id.replace(/-/g, '_'),
                    id.replace(/\s+/g, '-'),
                    id.replace(/\s+/g, '_')
                ];

                // Add encoded/decoded variations
                try {
                    variations.push(encodeURIComponent(id));
                    variations.push(decodeURIComponent(id));
                } catch (e) {
                    // Ignore
                }

                for (const variant of variations) {
                    if (variant && variant !== id) {
                        targetElement = safeQuerySelector(variant);
                        if (targetElement) return targetElement;
                    }
                }

                // Try finding by text content (fallback) - supports UTF-8
                const allHeaders = output.querySelectorAll('h1, h2, h3, h4, h5, h6');
                for (let header of allHeaders) {
                    const headerId = header.id || '';
                    const headerText = header.textContent.trim();

                    // Match by ID (exact or normalized) - UTF-8 aware
                    if (headerId === id ||
                        headerId === cleanId ||
                        headerId === normalizedId ||
                        headerId === encodeURIComponent(id) ||
                        headerId === decodeURIComponent(id)) {
                        return header;
                    }

                    // Match by text content - preserve UTF-8 characters
                    const normalizedText = headerText
                        .trim()
                        .replace(/\s+/g, '-')
                        .replace(/-+/g, '-')
                        .replace(/^-+|-+$/g, '');

                    const normalizedIdFromText = id.trim()
                        .replace(/\s+/g, '-')
                        .replace(/-+/g, '-')
                        .replace(/^-+|-+$/g, '');

                    if (normalizedText === normalizedIdFromText ||
                        headerText === id ||
                        headerText === cleanId ||
                        headerText.toLowerCase() === id.toLowerCase()) {
                        return header;
                    }

                    // Also try matching raw text directly
                    if (headerText === id || headerText.includes(id) || id.includes(headerText)) {
                        return header;
                    }
                }

                return null;
            }

            const targetElement = findTargetElement(hash);

            if (targetElement) {
                // Scroll to target within preview output (which is the scrollable container)
                const scrollContainer = output; // output is #preview-output

                if (scrollContainer) {
                    // Wait a bit for DOM to be ready
                    setTimeout(() => {
                        // Calculate scroll position relative to the scroll container
                        const containerRect = scrollContainer.getBoundingClientRect();
                        const targetRect = targetElement.getBoundingClientRect();

                        // Get current scroll position
                        const currentScrollTop = scrollContainer.scrollTop;

                        // Calculate target scroll position
                        const targetScrollTop = currentScrollTop + (targetRect.top - containerRect.top) - 20; // 20px offset from top

                        // Scroll to target
                        scrollContainer.scrollTo({
                            top: Math.max(0, targetScrollTop),
                            behavior: 'smooth'
                        });
                    }, 100);
                } else {
                    // Fallback: use scrollIntoView
                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }
        }

        // Listen for hash changes globally
        window.addEventListener('hashchange', handleHashChange);

        window.addEventListener('DOMContentLoaded', function () {
            const input = document.getElementById('markdown-input');
            // Set fixed categorized example with editor intro
            input.value = editorIntro + fixedExamples;

            // Add input event listener - debounced
            input.addEventListener('input', function () {
                // Debounce syntax check and line number updates
                if (syntaxCheckTimer) {
                    clearTimeout(syntaxCheckTimer);
                }

                syntaxCheckTimer = setTimeout(() => {
                    checkSyntaxImmediately();
                }, 50); // 50ms delay is imperceptible but prevents blocking on every keystroke

                // Debounce preview update for better performance
                if (previewUpdateTimer) {
                    clearTimeout(previewUpdateTimer);
                }
                previewUpdateTimer = setTimeout(() => {
                    updatePreview();
                }, 150); // 150ms debounce for preview

                // If ToC insert or Auto title is enabled, update it with debounce
                if (document.getElementById('toc-insert').checked || document.getElementById('export-auto-title').checked) {
                    debouncedUpdateToc();
                } else {
                    // Restore title if both disabled
                    document.title = originalPageTitle;
                }
            });

            // Also check syntax on paste events
            input.addEventListener('paste', function () {
                // Use setTimeout to check after paste content is inserted
                setTimeout(() => {
                    checkSyntaxImmediately();
                }, 100);
            });

            // Sync scroll: Editor -> Preview
            input.addEventListener('scroll', function () {
                syncLineNumbersScroll();
                syncPreviewScroll();
            });

            // Sync scroll: Preview -> Editor
            const output = document.getElementById('preview-output');
            output.addEventListener('scroll', function () {
                const syncScroll = getSyncScroll();
                if (syncScroll && typeof syncScroll.syncReverse === 'function') {
                    syncScroll.syncReverse();
                }
            });

            // Preference Persistence
            function savePreferences() {
                try {
                    const prefs = {
                        enableLatex: document.getElementById('enable-latex').checked,
                        enableMermaid: document.getElementById('enable-mermaid').checked,
                        exportAutoTitle: document.getElementById('export-auto-title').checked,
                        tocInsert: document.getElementById('toc-insert').checked,
                        tocLevels: document.getElementById('toc-levels').value,
                        enableWatermark: document.getElementById('enable-watermark').checked,
                        watermarkText: document.getElementById('watermark-text').value,
                        watermarkType: document.getElementById('watermark-type').value,
                        enableBgColor: document.getElementById('enable-bg-color').checked,
                        bgColor: document.getElementById('bg-color').value,
                        exportFormat: document.getElementById('export-format').value
                    };
                    localStorage.setItem('markdown2pdf_prefs', JSON.stringify(prefs));
                } catch (e) {
                    console.error('Failed to save preferences:', e);
                }
            }

            function loadPreferences() {
                try {
                    const prefsStr = localStorage.getItem('markdown2pdf_prefs');
                    if (!prefsStr) return;

                    const prefs = JSON.parse(prefsStr);

                    // Helper to safe-set checkbox
                    const setCheck = (id, val) => {
                        const el = document.getElementById(id);
                        if (el && typeof val === 'boolean') el.checked = val;
                    };
                    // Helper to safe-set value
                    const setVal = (id, val) => {
                        const el = document.getElementById(id);
                        if (el && val !== undefined) el.value = val;
                    };

                    setCheck('enable-latex', prefs.enableLatex);
                    setCheck('enable-mermaid', prefs.enableMermaid);
                    setCheck('export-auto-title', prefs.exportAutoTitle);
                    setCheck('toc-insert', prefs.tocInsert);
                    setVal('toc-levels', prefs.tocLevels);

                    setCheck('enable-watermark', prefs.enableWatermark);
                    setVal('watermark-text', prefs.watermarkText);
                    setVal('watermark-type', prefs.watermarkType);

                    setCheck('enable-bg-color', prefs.enableBgColor);
                    setVal('bg-color', prefs.bgColor);

                    setVal('export-format', prefs.exportFormat);

                    // Trigger updates based on loaded values
                    // Watermark
                    if (typeof updateWatermark === 'function') updateWatermark();
                    // Bg Color
                    if (typeof changeBgColor === 'function') changeBgColor();
                    // Export Mode (Preview)
                    if (typeof updateExportMode === 'function') updateExportMode();

                } catch (e) {
                    console.error('Failed to load preferences:', e);
                }
            }

            // Attach listeners for auto-saving
            function attachPreferenceListeners() {
                const ids = [
                    'enable-latex', 'enable-mermaid', 'export-auto-title', 'toc-insert', 'toc-levels',
                    'enable-watermark', 'watermark-text', 'watermark-type',
                    'enable-bg-color', 'bg-color', 'export-format'
                ];

                ids.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.addEventListener('change', savePreferences);
                        // For text inputs, also save on input (debounced or just on blur usually, but change covers blur)
                        if (el.tagName === 'INPUT' && el.type === 'text') {
                            el.addEventListener('input', () => {
                                // Debounce save for text input
                                if (window._saveTimer) clearTimeout(window._saveTimer);
                                window._saveTimer = setTimeout(savePreferences, 500);
                            });
                        }
                    }
                });
            }

            // Initial update - use requestIdleCallback to avoid blocking
            // This is especially important for HTTP protocol where navigation rendering might compete
            const performInitialRender = () => {
                loadPreferences(); // Load prefs first
                attachPreferenceListeners(); // Then attach listeners
                updateLineNumbers();
                updatePreview();
                changeStyle();
                changeFont();
            };

            // Use requestIdleCallback if available, otherwise setTimeout
            if ('requestIdleCallback' in window) {
                requestIdleCallback(performInitialRender, { timeout: 2000 });
            } else {
                setTimeout(performInitialRender, 100);
            }

            // Initialize sync scroll feature (from main.js)
            // Use a more robust initialization that waits for main.js to be available
            function initSyncScroll() {
                // Try multiple ways to access md2pdfSyncScroll
                let syncScroll = null;

                // Method 1: Direct reference
                if (typeof md2pdfSyncScroll !== 'undefined') {
                    syncScroll = md2pdfSyncScroll;
                }
                // Method 2: Window reference
                else if (typeof window !== 'undefined' && window.md2pdfSyncScroll) {
                    syncScroll = window.md2pdfSyncScroll;
                }
                // Method 3: Try to access from global scope
                else if (typeof globalThis !== 'undefined' && globalThis.md2pdfSyncScroll) {
                    syncScroll = globalThis.md2pdfSyncScroll;
                }

                if (syncScroll && typeof syncScroll.init === 'function') {
                    try {
                        syncScroll.init();
                        return true;
                    } catch (e) {
                        console.error('Error initializing sync scroll:', e);
                        return false;
                    }
                }
                return false;
            }

            // Try immediately (main.js should be loaded by now since it's in <head>)
            if (!initSyncScroll()) {
                // If not available, retry with delays (in case of async loading issues)
                let retryCount = 0;
                const maxRetries = 20; // Increased retries
                const retryInterval = setInterval(() => {
                    retryCount++;
                    if (initSyncScroll()) {
                        clearInterval(retryInterval);
                    } else if (retryCount >= maxRetries) {
                        clearInterval(retryInterval);
                        // Only warn if it's still not available after all retries
                        console.warn('md2pdfSyncScroll not available after', maxRetries, 'retries. Sync scroll feature will be disabled.');
                        // Disable the checkbox to indicate feature is unavailable
                        const syncScrollCheckbox = document.getElementById('sync-scroll');
                        if (syncScrollCheckbox) {
                            syncScrollCheckbox.disabled = true;
                            syncScrollCheckbox.title = 'Sync scroll feature unavailable (main.js not loaded)';
                        }
                    }
                }, 50);
            }

            // Apply language on load
            if (typeof applyLanguage === 'function') {
                const savedLang = localStorage.getItem('lang') || 'zh';
                applyLanguage(savedLang);
            }

            // Handle initial hash if present
            if (window.location.hash) {
                setTimeout(() => {
                    handleHashChange();
                }, 800); // Wait for preview to render
            }
        });
    </script>

    <!-- Standardized Footer -->

    <!-- Floating Buttons -->
    <div id="back-to-top" title="Back to Top">
        <svg viewBox="0 0 24 24">
            <path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path>
        </svg>
    </div>
</body>

</html>
